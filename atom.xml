<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chaosky&#39;s Notes</title>
  
  <subtitle>Strategy, Execution, Communication.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chaosky.tech/"/>
  <updated>2020-03-16T07:31:28.344Z</updated>
  <id>http://chaosky.tech/</id>
  
  <author>
    <name>Alex Lin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>苹果开发者账号申请或续费</title>
    <link href="http://chaosky.tech/2019/12/17/Apple-Developer-Program/"/>
    <id>http://chaosky.tech/2019/12/17/Apple-Developer-Program/</id>
    <published>2019-12-17T02:29:18.000Z</published>
    <updated>2020-03-16T07:31:28.344Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="尝试支付"><a href="#尝试支付" class="headerlink" title="尝试支付"></a>尝试支付</h3><p>使用国际信用卡（Master或Visa）务必保证账单地址正确，否则会导致支付失败。</p><p>我使用的是招行的Visa信用卡，账单地址可以从招行的掌上生活 App 搜索账单地址可以找到。</p><h3 id="无法支付或支付失败"><a href="#无法支付或支付失败" class="headerlink" title="无法支付或支付失败"></a>无法支付或支付失败</h3><ul><li><p>周一到周五，早上9点到下午5点。</p></li><li><p>登录开发者中心，左侧，Contact Us，选择会员资格与帐户—&gt;计划购买和续订。</p></li><li><p>填电话号码，苹果客服会打电话给你。</p></li><li><p>接通10秒左右按1与技术顾问交谈，你就跟客服说，无法支付年费，让他们给解决的方法。</p></li><li><p>他们一般会让你先多尝试，你要先做一些支付失败的记录。</p></li><li><p>然后跟他们说，确实无法支付，他们就会给你两种方案其中一种，不一定是哪一种。</p></li><li><p>第一种是直接信用卡划扣，他们会问你有没有国际信用卡，Master或Visa的。</p><p>然后要你给卡号，过期时间，还有账单地址，给你尝试手动划扣99美金，扣成功的话，就直接成功了。</p></li><li><p>第二种是让你电汇到苹果公司的账号。<br>他们会手动帮你生成一个订单，然后要转账99美金到他们苹果美国的银行账号里。<br>然后转账附言上订单号。<br>可以使用建行，我是用这个解决的，要有U盾。<br>先购汇99美金，大概690+人民币，然后电汇需要手续费20+80，就是100块手续费。<br>大概就是800左右了。<br>电汇成功后回复邮件告诉他们已经电汇了，就行了，一般隔日账号就通过了。</p></li><li><p>以上。</p></li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ol><li>苹果开发者中心联系电话：<a href="https://developer.apple.com/contact/phone/cn/" target="_blank" rel="noopener">https://developer.apple.com/contact/phone/cn/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosky.tech/categories/iOS/"/>
    
    
      <category term="开发者账号" scheme="http://chaosky.tech/tags/%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Block 分析</title>
    <link href="http://chaosky.tech/2017/08/31/Objective-C-Block/"/>
    <id>http://chaosky.tech/2017/08/31/Objective-C-Block/</id>
    <published>2017-08-31T13:38:29.000Z</published>
    <updated>2020-03-16T07:31:28.343Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="分析工具：clang"><a href="#分析工具：clang" class="headerlink" title="分析工具：clang"></a>分析工具：clang</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc test.m</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> UIKit</span><br><span class="line">clang -x objective-c -rewrite-objc -isysroot <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneSimulator.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneSimulator.sdk xxxxx.m</span></span><br></pre></td></tr></table></figure><h2 id="block-的数据结构定义"><a href="#block-的数据结构定义" class="headerlink" title="block 的数据结构定义"></a>block 的数据结构定义</h2><p><img src="http://blog.devtang.com/images/block-struct.jpg" alt=""></p><p>对应的结构体定义如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">void</span> (*copy)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor</span> *<span class="title">descriptor</span>;</span></span><br><span class="line">    <span class="comment">/* Imported variables. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="block-的三种类型"><a href="#block-的三种类型" class="headerlink" title="block 的三种类型"></a>block 的三种类型</h2><ol><li>_NSConcreteGlobalBlock 全局的静态 block，不会访问任何外部变量。</li><li>_NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销毁。</li><li>_NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁。</li></ol><p><img src="http://file.blog.chaosky.tech/1155481-5436194b4c0899b8.png" alt=""></p><p>block对变量的捕获规则：</p><ol><li><p>静态存储区的变量：例如全局变量、方法中的static变量<br> 引用，可修改。</p></li><li><p>block接受的参数<br> 传值，可修改，和一般函数的参数相同。</p></li><li><p>栈变量 (被捕获的上下文变量)<br> const，不可修改。 当block被copy后，block会对 id类型的变量产生强引用。<br> 每次执行block时,捕获到的变量都是最初的值。</p></li><li><p>栈变量 (有__block前缀)<br> 引用，可以修改。如果时id类型则不会被block retain,必须手动处理其内存管理。<br> 如果该类型是C类型变量，block被copy到heap后,该值也会被挪动到heap</p></li></ol><h2 id="变量的复制"><a href="#变量的复制" class="headerlink" title="变量的复制"></a>变量的复制</h2><p>对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的。</p><p><img src="http://blog.devtang.com/images/block-capture-1.jpg" alt=""></p><p>对于用 __block 修饰的外部变量引用，block 是复制其引用地址来实现访问的。</p><p><img src="http://blog.devtang.com/images/block-capture-2.jpg" alt=""></p><h2 id="嵌套block"><a href="#嵌套block" class="headerlink" title="嵌套block"></a>嵌套block</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setUpModel&#123;</span><br><span class="line">    XYModel *model = [XYModel new];</span><br><span class="line"></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    model.dataChanged = ^(<span class="built_in">NSString</span> *title) &#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) strongSelf = weakSelf;</span><br><span class="line">        strongSelf.titleLabel.text = title;</span><br><span class="line"></span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf2 = strongSelf;</span><br><span class="line">        strongSelf.model.dataChanged = ^(<span class="built_in">NSString</span> *title2) &#123;</span><br><span class="line">            __<span class="keyword">strong</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) strongSelf2 = weakSelf2;</span><br><span class="line">            strongSelf2.titleLabel.text = title2;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.model = model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就避免的引用循环，总结一下，不管都多少个block嵌套，皆按此法</p><h2 id="weakify-strongify-使用"><a href="#weakify-strongify-使用" class="headerlink" title="@weakify, @strongify 使用"></a>@weakify, @strongify 使用</h2><script src="https://gist.github.com/chaoskyme/041628148019749e13f49756010eea94.js"></script><ol><li><p>weakify(self)展开后是: *<em>weak typeof(self) *</em>weak_self = self;</p></li><li><p>strongify(self)展开后是：*<em>strong typeof(self) self = *</em>weak_self;</p></li><li><p>在block中使用strongify(self);的目的是确保在block作用域内self不会被其它线程释放掉</p></li><li><p>以前我们在block中直接使用__weak_self来解除循环引用。这本身没有问题，之所以还要加strongify(self)就是为了避免block中代码执行过程中由于其它线程释放了self导致block内执行的逻辑出现问题。例如：会出现执行前几句代码时访问self还是存在的，但后面的self调用已经变为nil了</p></li><li><p>如果是在block外部定义strongify(self)虽然在block中的self还是指向(跳转到定义)这个strongify(self)。但因为方法调用结束后strongify(self)定义的局部self变量被释放了，所以这种做法就回退到了[4]</p></li><li><p>由5可知，如果block中有多个嵌套的block异步调用，那么每一个block中都要再定义一个strongify(self);</p></li><li><p>虽然在多层嵌套的block中，定义weakify(self)也是可行的。但是不推荐这么做</p></li><li><p>swift中使用unowned和weak来解决循环引用问题，基本原理同OC。但unowned本质上是__unsafe_unretained即assign，所以使用起来要小心野指针。还是推荐无脑用weak</p></li><li><p>不过要达到[3]中的效果，就要在当前closure的作用域内retain下self，只不过有个小麻烦是没法像OC中写的那么自然——不能使用self了。例子如下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">obj.doSomething</span> &#123;[weak <span class="keyword">self] </span>in</span><br><span class="line">  <span class="meta">if</span> let <span class="keyword">strong_self </span>= <span class="keyword">self </span>&#123;</span><br><span class="line">      <span class="keyword">strong_self.Member_XXX</span></span><br><span class="line"><span class="keyword"> </span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>总结：多层嵌套的block，只需要对最外层block传入的<code>self</code>进行weak化即可。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="noopener">谈Objective-C block的实现</a></li><li><a href="https://www.zybuluo.com/MicroCai/note/51116" target="_blank" rel="noopener"> block没那么难（一）：block的实现</a></li><li><a href="https://www.zybuluo.com/MicroCai/note/57603" target="_blank" rel="noopener"> block没那么难（二）：block和变量的内存管理</a></li><li><a href="https://www.zybuluo.com/MicroCai/note/58470" target="_blank" rel="noopener"> block没那么难（三）：block和对象的内存管理</a></li><li><a href="http://www.jianshu.com/p/ee9756f3d5f6#" target="_blank" rel="noopener">深入研究Block捕获外部变量和__block实现原理</a></li><li><a href="http://www.jianshu.com/p/701da54bd78c" target="_blank" rel="noopener">深入研究Block用weakSelf、strongSelf、@weakify、@strongify解决循环引用</a></li><li><a href="http://draveness.me/block-retain-object.html" target="_blank" rel="noopener">iOS 中的 block 是如何持有对象的</a></li><li><a href="http://blog.ibireme.com/2013/11/27/objc-block/" target="_blank" rel="noopener">objc 中的 block</a></li><li><a href="http://www.90159.com/2015/08/04/ios-block-ultimate/" target="_blank" rel="noopener">iOS开发之block终极篇</a></li><li><a href="http://www.wangjiawen.com/ios/ios-block-usage-and-implementation" target="_blank" rel="noopener">iOS Block用法和实现原理</a></li><li><a href="http://www.cnblogs.com/iOS-mt/p/4227336.html" target="_blank" rel="noopener">OC高级编程——深入block，如何捕获变量，如何存储在堆上</a></li><li><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-1/" target="_blank" rel="noopener">A look inside blocks: Episode 1</a></li><li><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-2/" target="_blank" rel="noopener">A look inside blocks: Episode 2</a></li><li><a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/" target="_blank" rel="noopener">A look inside blocks: Episode 3</a></li><li><a href="http://www.cnblogs.com/biosli/archive/2013/05/29/iOS_Objective-C_Block.html" target="_blank" rel="noopener">对 Objective-C 中 Block 的追探</a></li><li><a href="https://opensource.apple.com/source/libclosure/libclosure-63/" target="_blank" rel="noopener">LLVM 中 block 实现源码</a></li><li><a href="http://blog.parse.com/2013/02/05/objective-c-blocks-quiz/" target="_blank" rel="noopener">objective-c-blocks-quiz</a></li><li><a href="http://fuckingclangwarnings.com" target="_blank" rel="noopener">Which Clang Warning Is Generating This Message?</a></li><li><a href="http://www.jianshu.com/p/bc15591784ce" target="_blank" rel="noopener">iOS 内存泄漏分析</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosky.tech/categories/iOS/"/>
    
    
      <category term="Block" scheme="http://chaosky.tech/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>OS X Cocos2d-x 环境搭建</title>
    <link href="http://chaosky.tech/2017/02/23/Cocos2d-x-Install/"/>
    <id>http://chaosky.tech/2017/02/23/Cocos2d-x-Install/</id>
    <published>2017-02-23T14:32:32.000Z</published>
    <updated>2020-03-16T07:31:28.342Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Cocos2d-x-引擎"><a href="#Cocos2d-x-引擎" class="headerlink" title="Cocos2d-x 引擎"></a>Cocos2d-x 引擎</h2><p>Cocos2d-x引擎可在 Cocos官网下载，其下载地址为：<a href="http://www.cocos.com/download/" target="_blank" rel="noopener">http://www.cocos.com/download/</a>。当然，亦可从Cocos2d-x的 GitHub 仓库拉取，仓库地址：<a href="https://github.com/cocos2d/cocos2d-x" target="_blank" rel="noopener">https://github.com/cocos2d/cocos2d-x</a>。下载完成后，引擎包的主要内容下。<br><img src="http://file.blog.chaosky.tech/2017-03-06-framework_architecture.jpg" alt="framework_architecture"></p><ul><li>AUTHORS：作者目录，包含所有给Cocos2d-x引擎贡献代码的开发者</li><li>build：包含测试例子、cocos2d_lib的Xcode以及Visual Studio工程</li><li>CHANGELOG：所有历史版本详细改动列表</li><li>CMakeLists.txt：cmake配置文件</li><li>cocos：Cocos2d-x引擎源代码</li><li>CONTRIBUTING.md：贡献代码指南</li><li>docs：包含JavaScript代码风格规范、当前发布说明和当前版本升级指南</li><li>download-deps.py：下载第三方库的脚本</li><li>extensions：第三方扩展</li><li>external：存放第三方库的文件夹</li><li>licenses：所有许可协议</li><li>plugin：插件</li><li>README.cmake：针对cmake用法的说明文件</li><li>README.md：Cocos2d-x引擎简介</li><li>setup.py：Cocos Console的安装脚本</li><li>templates：Cocos Console创建项目时使用的模板</li><li>tests：各分支的测试项目</li><li>tools：工具文件夹</li><li>—bindings-generator：脚本绑定工具</li><li>—cocos2d-console：Cocos Console工具</li><li>—tojs：JSB自动绑定配置文件以及生成脚本</li><li>—tolua：Lua绑定配置文件以及生成脚本</li><li>web：Cocos2d-JS游戏引擎</li></ul><a id="more"></a><h2 id="Cocos-Console"><a href="#Cocos-Console" class="headerlink" title="Cocos Console"></a>Cocos Console</h2><p>Cocos Console 是 Cocos2d-x 引擎下的一个命令行工具，它用来管理 Cocos 工程，其中包含创建、运行、编译、调试以及打包项目等。</p><p>Cocos Console 位于引擎包 cocos2d-x/tools/cocos2d-console 目录下，通过运行引擎包目录下的 setup.py 脚本即可安装。在安装的过程中，Cocos Console 需要开发者提供 Android NDK、Android SDK 和 Apache ANT 的文件路径。另外，Cocos Console 是一个采用 Python 语言编写的跨平台脚本工具，所以在安装Cocos Console 之前，需要先安装好Python。</p><h3 id="安装-Python"><a href="#安装-Python" class="headerlink" title="安装 Python"></a>安装 Python</h3><p>在 Mac OS X 中，操作系统本身自带了 Python，而在 Windows 操作系统中，Python 则需要我们自行下载并安装，其下载地址为：<a href="https://www.python.org/downloads/index.html" target="_blank" rel="noopener">https://www.python.org/downloads/index.html</a>。若你的Mac OS X系统中没有Python，也可通过此地址下载安装。下载至Mac OS X和Windows上的安装包分别是一个.pkg或者.msi文件。</p><p>打开终端，输入 <code>python --version</code>。若提示 Python 版本号，则说明 Python 安装成功。</p><h3 id="Android-环境配置"><a href="#Android-环境配置" class="headerlink" title="Android 环境配置"></a>Android 环境配置</h3><p>当安装好 Python 之后，你便可以开始准备 Android 相关的软件包了。当然，若你不需要支持 Android，除了 Apache Ant 之外，其余步骤可以跳过，不必配置。</p><ul><li><strong>Apache Ant</strong>：将软件编译、测试、部署等步骤联系在一起加以自动化的一个工具，大多用于Java环境中的软件开发。下载地址：<a href="http://ant.apache.org/bindownload.cgi" target="_blank" rel="noopener">http://ant.apache.org/bindownload.cgi</a>。</li><li><strong>Android SDK</strong>：即Software Development Kit的简称，中文译为软件开发工具包。在Android 中，它为开发者提供了库文件以及其他开发所用到的工具。下载地址：&lt;<a href="http://developer.android.com/" target="_blank" rel="noopener">http://developer.android.com/</a> tools/sdk/ndk/index.html&gt;。</li><li><strong>Android NDK</strong>：即Native Development Kit的简称，它是一系列工具的集合，可以帮助开发 者快速开发C/C++的动态库。另外，它还能自动将.so文件和Java应用一起打包成.apk。下 载地址：<a href="https://developer.android.com/sdk/index.html?hl=sk" target="_blank" rel="noopener">https://developer.android.com/sdk/index.html?hl=sk</a>。</li><li><strong>JDK</strong>：Java的开发工具包，包括Java运行环境、Java工具和Java基础类库。下载地址：<a href="https://www.oracle.com/downloads/index.html" target="_blank" rel="noopener">https://www.oracle.com/downloads/index.html</a>。</li></ul><h3 id="安装-Cocos-Console"><a href="#安装-Cocos-Console" class="headerlink" title="安装 Cocos Console"></a>安装 Cocos Console</h3><p>打开终端，进入 Cocos2d-x 引擎目录下，然后再运行setup.py脚本，相关命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /Users/Chaosky/Cocos/cocos2d-x-3.14.1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python setup.py</span></span><br></pre></td></tr></table></figure><p>然后根据提示，将Cocos Console所需的文件路径拖曳进去，最后根据末尾行提示进行对应的操作。<br>![Jietu20170306-170411]<a href="http://file.blog.chaosky.tech/2017-03-06-Jietu20170306-170411.png" target="_blank" rel="noopener">http://file.blog.chaosky.tech/2017-03-06-Jietu20170306-170411.png</a>)</p><p>此时，Cocos Console安装成功。若要卸载Cocos Console，则Mac OS X用户可删除 <code>/Users/用户名/下.bash_profile或者.zshrc</code> 文件中对应的值，而Windows用户只需删除对应的系统环境变量值即可。</p><h2 id="创建、编译和运行工程"><a href="#创建、编译和运行工程" class="headerlink" title="创建、编译和运行工程"></a>创建、编译和运行工程</h2><p>在终端中执行 <code>cocos --help</code>，查看 cocos 命令行工具集的功能。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ cocos --<span class="keyword">help</span></span><br><span class="line"></span><br><span class="line">可用的命令：</span><br><span class="line">run              在设备或者模拟器上编译，部署和运行工程。</span><br><span class="line">gen-libs         生成引擎的预编译库。生成的库文件会保存在引擎根目录的 <span class="string">'prebuilt'</span> 文件夹。</span><br><span class="line">luacompile       对 <span class="keyword">lua</span> 文件进行加密和编译为字节码的处理。</span><br><span class="line">deploy           编译并在设备或模拟器上部署工程。</span><br><span class="line">package          管理 cocos 中的 package。</span><br><span class="line">compile          编译并打包工程。</span><br><span class="line">gen-simulator    生成 Cocos 模拟器。</span><br><span class="line"><span class="keyword">new</span>              创建一个新的工程。</span><br><span class="line">jscompile        对 js 文件进行加密和压缩处理。</span><br><span class="line">gen-templates    生成用于 Cocos Framework 环境的模板。</span><br><span class="line"></span><br><span class="line">可用的参数：</span><br><span class="line">-h, --<span class="keyword">help</span>显示帮助信息。</span><br><span class="line">-v, --<span class="keyword">version</span>显示命令行工具的版本号。</span><br><span class="line">--<span class="keyword">ol</span> [<span class="string">'en'</span>, <span class="string">'zh'</span>, <span class="string">'zh_tr'</span>]指定输出信息的语言。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">cocos <span class="keyword">new</span> --<span class="keyword">help</span></span><br><span class="line">cocos run --<span class="keyword">help</span></span><br></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>终端中输入<code>cocos new --help</code>查看功能。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ cocos <span class="keyword">new</span> --<span class="keyword">help</span></span><br><span class="line"></span><br><span class="line">usage: cocos <span class="keyword">new</span> [-h] [-<span class="keyword">p</span> PACKAGE_NAME] [-d DIRECTORY] [-t TEMPLATE_NAME]</span><br><span class="line">                 [--ios-bundleid IOS_BUNDLEID] [--mac-bundleid MAC_BUNDLEID]</span><br><span class="line">                 [-<span class="keyword">e</span> ENGINE_PATH] [--portrait] [--<span class="keyword">no</span>-native] -<span class="keyword">l</span> &#123;cpp,<span class="keyword">lua</span>,js&#125;</span><br><span class="line">                 [PROJECT_NAME]</span><br><span class="line"></span><br><span class="line">创建一个新的工程。</span><br><span class="line"></span><br><span class="line">positional <span class="keyword">argument</span><span class="variable">s:</span></span><br><span class="line">  PROJECT_NAME          设置工程名称。</span><br><span class="line"></span><br><span class="line">optional <span class="keyword">argument</span><span class="variable">s:</span></span><br><span class="line">  -h, --<span class="keyword">help</span>            show this <span class="keyword">help</span> message <span class="built_in">and</span> <span class="keyword">exit</span></span><br><span class="line">  -<span class="keyword">p</span> PACKAGE_NAME, --package PACKAGE_NAME</span><br><span class="line">                        设置工程的包名。</span><br><span class="line">  -d DIRECTORY, --directory DIRECTORY</span><br><span class="line">                        设置工程存放路径。</span><br><span class="line">  -t TEMPLATE_NAME, --template TEMPLATE_NAME</span><br><span class="line">                        设置使用的模板名称。</span><br><span class="line">  --ios-bundleid IOS_BUNDLEID</span><br><span class="line">                        设置工程的 iOS Bundle ID。</span><br><span class="line">  --mac-bundleid MAC_BUNDLEID</span><br><span class="line">                        设置工程的 Mac Bundle ID。</span><br><span class="line">  -<span class="keyword">e</span> ENGINE_PATH, --engine-path ENGINE_PATH</span><br><span class="line">                        设置引擎路径。</span><br><span class="line">  --portrait            设置工程为竖屏。</span><br><span class="line">  -<span class="keyword">l</span> &#123;cpp,<span class="keyword">lua</span>,js&#125;, --<span class="keyword">language</span> &#123;cpp,<span class="keyword">lua</span>,js&#125;</span><br><span class="line">                        设置工程使用的编程语言，可选值：[cpp |</span><br><span class="line">                        <span class="keyword">lua</span> | js]</span><br><span class="line"></span><br><span class="line"><span class="keyword">lua</span>/js 工程可用参数:</span><br><span class="line">  --<span class="keyword">no</span>-native           设置新建的工程不包含 C++</span><br><span class="line">                        代码与各平台工程。</span><br></pre></td></tr></table></figure><p>具体有几种方式：</p><ol><li><p>创建一个名为projectName，并同时包含Cocos2d-HTML5和Cocos2d-x JSB项目</p> <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cocos <span class="keyword">new</span> <span class="type">projectName</span> -l js</span><br></pre></td></tr></table></figure></li><li><p>创建一个名为projectName，且仅含Cocos2d-HTML5的项目， –no-native表示不需要支持Native平 台（iOS、Android、Mac、Windows等），仅支持浏览器即可</p> <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cocos <span class="keyword">new</span> projectName -l js --<span class="literal">no</span>-<span class="keyword">native</span></span><br></pre></td></tr></table></figure></li><li><p>在桌面上创建一个名为projectName的项目</p> <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cocos <span class="keyword">new</span> <span class="type">projectName</span> -l js -d ./Desktop</span><br></pre></td></tr></table></figure></li><li><p>在桌面上创建一个名为projectName的项目，并设置为竖屏</p> <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cocos <span class="keyword">new</span> projectName -l js -d ./Desktop <span class="comment">--portrait</span></span><br></pre></td></tr></table></figure><p>其中 <code>-l</code> 表示采用的语言，可选值为 cpp、lua以及js。</p></li></ol><h3 id="编译、部署、运行"><a href="#编译、部署、运行" class="headerlink" title="编译、部署、运行"></a>编译、部署、运行</h3><p>当项目创建完毕后，可以通过下列命令将项目运行在浏览器中：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ./Desktop/HelloWorld cocos <span class="keyword">run</span><span class="bash"> -p web</span></span><br></pre></td></tr></table></figure><p>除创建命令外，Cocos Console还为工程提供了运行、编译等命令，具体如下：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 运行在指定的平台上</span><br><span class="line">cocos run -p web|<span class="type">ios</span>|<span class="type">android</span>|<span class="type">mac</span>|<span class="type">win32</span></span><br><span class="line">// 将项目工程打包到指定的平台上</span><br><span class="line">cocos compile -p web|<span class="type">ios</span>|<span class="type">android</span>|<span class="type">mac</span>|<span class="type">win32</span> -m release</span><br></pre></td></tr></table></figure><p>Cocos Console提供了相关的help指令，方便开发者查询Cocos Console相关的指令。下面举几个 help指令的例子，其中help可用字母h替代：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cocos <span class="keyword">new</span> <span class="comment">--help</span></span><br><span class="line">cocos run <span class="comment">--help</span></span><br><span class="line">cocos compile <span class="comment">--help</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Cocos2d-x-引擎&quot;&gt;&lt;a href=&quot;#Cocos2d-x-引擎&quot; class=&quot;headerlink&quot; title=&quot;Cocos2d-x 引擎&quot;&gt;&lt;/a&gt;Cocos2d-x 引擎&lt;/h2&gt;&lt;p&gt;Cocos2d-x引擎可在 Cocos官网下载，其下载地址为：&lt;a href=&quot;http://www.cocos.com/download/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cocos.com/download/&lt;/a&gt;。当然，亦可从Cocos2d-x的 GitHub 仓库拉取，仓库地址：&lt;a href=&quot;https://github.com/cocos2d/cocos2d-x&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/cocos2d/cocos2d-x&lt;/a&gt;。下载完成后，引擎包的主要内容下。&lt;br&gt;&lt;img src=&quot;http://file.blog.chaosky.tech/2017-03-06-framework_architecture.jpg&quot; alt=&quot;framework_architecture&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AUTHORS：作者目录，包含所有给Cocos2d-x引擎贡献代码的开发者&lt;/li&gt;
&lt;li&gt;build：包含测试例子、cocos2d_lib的Xcode以及Visual Studio工程&lt;/li&gt;
&lt;li&gt;CHANGELOG：所有历史版本详细改动列表&lt;/li&gt;
&lt;li&gt;CMakeLists.txt：cmake配置文件&lt;/li&gt;
&lt;li&gt;cocos：Cocos2d-x引擎源代码&lt;/li&gt;
&lt;li&gt;CONTRIBUTING.md：贡献代码指南&lt;/li&gt;
&lt;li&gt;docs：包含JavaScript代码风格规范、当前发布说明和当前版本升级指南&lt;/li&gt;
&lt;li&gt;download-deps.py：下载第三方库的脚本&lt;/li&gt;
&lt;li&gt;extensions：第三方扩展&lt;/li&gt;
&lt;li&gt;external：存放第三方库的文件夹&lt;/li&gt;
&lt;li&gt;licenses：所有许可协议&lt;/li&gt;
&lt;li&gt;plugin：插件&lt;/li&gt;
&lt;li&gt;README.cmake：针对cmake用法的说明文件&lt;/li&gt;
&lt;li&gt;README.md：Cocos2d-x引擎简介&lt;/li&gt;
&lt;li&gt;setup.py：Cocos Console的安装脚本&lt;/li&gt;
&lt;li&gt;templates：Cocos Console创建项目时使用的模板&lt;/li&gt;
&lt;li&gt;tests：各分支的测试项目&lt;/li&gt;
&lt;li&gt;tools：工具文件夹&lt;/li&gt;
&lt;li&gt;—bindings-generator：脚本绑定工具&lt;/li&gt;
&lt;li&gt;—cocos2d-console：Cocos Console工具&lt;/li&gt;
&lt;li&gt;—tojs：JSB自动绑定配置文件以及生成脚本&lt;/li&gt;
&lt;li&gt;—tolua：Lua绑定配置文件以及生成脚本&lt;/li&gt;
&lt;li&gt;web：Cocos2d-JS游戏引擎&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="游戏开发" scheme="http://chaosky.tech/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Cocos2d-x" scheme="http://chaosky.tech/tags/Cocos2d-x/"/>
    
  </entry>
  
  <entry>
    <title>软件团队模式和开发流程</title>
    <link href="http://chaosky.tech/2017/02/22/Team-Mode-Development-Process/"/>
    <id>http://chaosky.tech/2017/02/22/Team-Mode-Development-Process/</id>
    <published>2017-02-22T10:11:12.000Z</published>
    <updated>2020-03-16T07:31:28.341Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="软件团队的模式"><a href="#软件团队的模式" class="headerlink" title="软件团队的模式"></a>软件团队的模式</h2><h3 id="主治医师模式（Chief-Programmer-Team，Surgical-Team）"><a href="#主治医师模式（Chief-Programmer-Team，Surgical-Team）" class="headerlink" title="主治医师模式（Chief Programmer Team，Surgical Team）"></a>主治医师模式（Chief Programmer Team，Surgical Team）</h3><p>就像在手术台上那样，有一个主刀医师，其他人（麻醉，护士，器械）各司其职，为主刀医师服务。</p><p>这样的软件团队中，有首席程序员（Chief Programmer），他/她负责处理主要模块的设计和编码，其他成员从各种角度支持他/她的工作（后备程序员、系统管理员、工具开发、编程语言专家、业务专家）。</p><p>在一些学校里，软件工程的团队模式往往从这一模式退化为『一个学生干活，其余学生跟着打酱油』。</p><h3 id="明星模式（Super-star-Model）"><a href="#明星模式（Super-star-Model）" class="headerlink" title="明星模式（Super-star Model）"></a>明星模式（Super-star Model）</h3><p>主治医师模式运用到极点，可以蜕化为明星模式，在这里，明星的光芒盖过了团队其他人的总和。明星也是人，也会受伤，犯错误，如何让团队的利益最大化，而不是明星的利益最大化？如何让团队的价值在明星陨落之后任然能够保持？是这个模式要解决的问题。</p><h3 id="社区模式（Community-Model）"><a href="#社区模式（Community-Model）" class="headerlink" title="社区模式（Community Model）"></a>社区模式（Community Model）</h3><p>社区由很多志愿者参与，每个人参与自己感兴趣的项目，贡献力量，大部分人不拿报酬。这种模式的好处是『众人拾柴火焰高』，但是如果大家都只来烤火，不去拾柴；或者捡到的柴火质量太差，最后火也就熄灭了。<strong>『社区』并不意味着『随意』</strong>，一些成功社区项目（例如开发和维护Linux操作系统的社区），都有很严格的代码复审和签入的质量控制。</p><h3 id="业余剧团模式（Amateur-Theater-Team）"><a href="#业余剧团模式（Amateur-Theater-Team）" class="headerlink" title="业余剧团模式（Amateur Theater Team）"></a>业余剧团模式（Amateur Theater Team）</h3><p>这样的团队在每一个项目中，不同的人会挑选不同的角色。在下一个项目中，这些人也许会换一个完全不同的角色类型。各人在团队中听从一个中央指挥（导演）的指导和安排。在学生实践项目或培训项目中，这样的事情经常发生。</p><h3 id="秘密团队（Skunk-Work-Team）"><a href="#秘密团队（Skunk-Work-Team）" class="headerlink" title="秘密团队（Skunk Work Team）"></a>秘密团队（Skunk Work Team）</h3><p>一些软件项目在秘密状态下进行，别人不知道他们具体在做什么。这种模式的好处是：团队内部有极大的自由，没有外界的干扰（不用每周给别人介绍项目进展，听领导的最新指示，等等），团队成员有极大的投入。</p><h3 id="特工团队（SWAT）"><a href="#特工团队（SWAT）" class="headerlink" title="特工团队（SWAT）"></a>特工团队（SWAT）</h3><p>软件行业的一些团队由一些有特殊技能的专业人士组成，负责解决一些棘手而有紧迫性的问题。</p><h3 id="交响乐团模式（Orchestra）"><a href="#交响乐团模式（Orchestra）" class="headerlink" title="交响乐团模式（Orchestra）"></a>交响乐团模式（Orchestra）</h3><p>想象一下交响乐团的演奏，有下面的特点。</p><ul><li>家伙多，门类齐全。</li><li>各司其职，各自有专门场地，演奏期间没有聊天、走动等现象。</li><li>演奏都靠谱，同时看指挥的。</li><li>演奏的都是练习过多次的曲目，重在执行。</li></ul><p>当某个软件领域处于稳定成长阶段的时候，众多大型软件公司的开发团队就会才去这种模式。</p><h3 id="爵士乐模式（Jazz-Band）"><a href="#爵士乐模式（Jazz-Band）" class="headerlink" title="爵士乐模式（Jazz Band）"></a>爵士乐模式（Jazz Band）</h3><p>和交响乐团相比，这种模式有以下特点。</p><ul><li>不靠谱。他们演奏时都没有谱子。</li><li>没有现场指挥，平时有编曲起到协调和指导作用。</li><li>也有模式，架构师先吹出主题，然后他走到一旁抽烟去了，其余人员根据这个主题各自即兴发挥，最后迈尔斯加入，回应主题，像是对曲子的总结。</li><li>人数较少。</li></ul><h3 id="功能团队模式（Feature-Team）"><a href="#功能团队模式（Feature-Team）" class="headerlink" title="功能团队模式（Feature Team）"></a>功能团队模式（Feature Team）</h3><p>很多软件公式的团队最后都演变成功能团队，简而言之，就是具备不同能力的同事们平等协作，共同完成一个功能。</p><p>在这个功能完成之后，这些人又重新组织，和别的角色一起去完成下一个功能。他们之间没有管理和被管理的关系。大型软件公司里的不少团队都是采用这种模式。这些功能小组也称为Feature Crew，小组内的交流比较频繁。</p><p>每个小组都由一到三个人组成，每个小组都是一个有自主权的单元，可以自由选用最有利于他们完成工作的任何技术。但是，每个小组必须与其他小组就编码规范达成一致。</p><h3 id="官僚模式（Bureaucratic-Model）"><a href="#官僚模式（Bureaucratic-Model）" class="headerlink" title="官僚模式（Bureaucratic Model）"></a>官僚模式（Bureaucratic Model）</h3><p>这种模式脱胎于大机构的组织架构，几个人报告给一个小头目，几个小头目报告给中头目，依次而上。这种模式在软件开发中会出问题。因为成员之间不光有技术方面的合作和领导，同时还混进了组织上的领导和被领导关系。跨组织的合作变得比较困难，因为各自头顶上都有不同的老板。</p><p>这种模式如果应用不好，最后会变成『老板驱动』的开发流程。</p><a id="more"></a><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><h3 id="写了再改模式（Code-and-Fix）"><a href="#写了再改模式（Code-and-Fix）" class="headerlink" title="写了再改模式（Code-and-Fix）"></a>写了再改模式（Code-and-Fix）</h3><p>这个流程不需要太多其他准备或相关知识，大家上来就写代码，也许就能写出来，写不出来就改，也许能改好。当面临下面的任务时，也许这个方法是有用的。</p><ul><li>『只用一次』的程序</li><li>『看过了就扔』的原型</li><li>一些不实用的演示程序</li></ul><h3 id="瀑布模型（Waterfall-Model）"><a href="#瀑布模型（Waterfall-Model）" class="headerlink" title="瀑布模型（Waterfall Model）"></a>瀑布模型（Waterfall Model）</h3><p><img src="http://file.blog.chaosky.tech/2017-03-07-Jietu20170302-113416.png" alt="相邻步骤的回溯"><br><img src="http://file.blog.chaosky.tech/2017-03-07-Jietu20170302-113508.png" alt="收集反馈并改进"></p><p><img src="http://file.blog.chaosky.tech/2017-03-07-Jietu20170302-113540.png" alt="6种文档"></p><p><img src="http://file.blog.chaosky.tech/2017-03-07-Snip20170302_3.png" alt="子瀑布模型"></p><h3 id="Rational-Unified-Process统一流程（RUP）"><a href="#Rational-Unified-Process统一流程（RUP）" class="headerlink" title="Rational Unified Process统一流程（RUP）"></a>Rational Unified Process统一流程（RUP）</h3><p>RUP 把软件开发的各个阶段整合在一个统一的框架里。</p><p>要完成一个复杂的软件项目，团队的各种成员要在不同阶段做不同的事情，这些不同类型的工作在 RUP 中叫做规程（Discipline）或者工作流（Workflow）。</p><h4 id="业务建模"><a href="#业务建模" class="headerlink" title="业务建模"></a>业务建模</h4><p>为用户提供软件，就要理解目前用户的业务流程，但是精通计算机语言细节的工程师并不能马上理解对用户活动和期望值的各种自然语言描述。为了解决这个问题，业务建模（Business Modeling）工作流用精确的语言（通常是UML）把用户的活动描述出来。这个工作流的结果通常是用例（Use Case）。</p><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>有了用例之后，开发人员和用户要分析并确认软件系统得提供什么样的功能来满足用户的需求，功能有什么约束条件，如何验证功能满足了用户需求。这就是需求（Requirement）工作流的作用。</p><h4 id="分析和设计"><a href="#分析和设计" class="headerlink" title="分析和设计"></a>分析和设计</h4><p>分析和设计（Analysis &amp; Design）工作流将需求转换成系统的设计。这一步结束之后，团队成员就能知道系统有哪些子系统、模块，他们之间的关系是怎样的。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>在实现（Implementation）工作流中，工程师按照计划实现上一步产出的设计，将开发出的组件（Module），连同验证模块（例如：单元测试）提交到系统中。同时，工程师们集成由单个开发者（或小组）所产生的结果，通过手工或自动化的手段，把可执行的系统搭建出来。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>测试（Test）工作流要验证现阶段交付的所有组件的正确性、组件之间交互的正确性，以及检验所有的需求已被正确地实现。在这个工程中，发现、报告、会诊、修复各种缺陷，在软件部署之前保证质量达到预期要求。</p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>部署（Deployment）工作流的目的是生成最终版本并将软件分发给最终用户。</p><h4 id="配置和变更管理"><a href="#配置和变更管理" class="headerlink" title="配置和变更管理"></a>配置和变更管理</h4><p>配置和变更管理工作流（Configuration and Change Management）负责管理 RUP 各个阶段产生的各种工作结果（例如源代码控制系统管理和备份各种源文件），要记录修改人员、修改原因、修改时间等属性，有些团队还可以考虑并行开发、分布式开发等。</p><h4 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h4><p>软件项目管理工作流（Project Management）平衡各种可能产生冲突的目标，管理风险，克服各种约束并成功地在各个阶段交付达到要求的产品。</p><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>环境（Environment）工作流的目的是向软件开发组织提供软件开发环境，包括工程和工具。</p><p>RUP 把软件开发分成几个阶段，一个大阶段的结束称为一个里程碑（Milestone），每个阶段内可以有几个迭代，以比较灵活的形式实现本阶段的任务。从这一点来说，RUP在大尺度上像瀑布模型，在每个阶段内像迭代模型。</p><p>四个阶段：</p><p><strong>初始阶段</strong>——此阶段的目标是分析软件系统大概的构成，系统与外部系统的边界在哪里（我们的系统究竟和什么别的外部实体打交道），大致的成本和预算是多少，系统的风险主要来自哪里，成功度过初始阶段的项目会达到生命周期目标（Lifecycle Objective）里程碑。</p><p><strong>细化阶段</strong>——它的目标是分析问题领域，建立健全的体系结构基础，编制目标计划，按优先级处理项目中的风险。团队要确定项目的具体范围、主要功能、性能、安全性、可扩展性等非功能需求。同时为项目建立支持环境，包括创建开发案例、创建模板并准备工具。细化阶段结束时，项目达到了第二个重要的里程碑：生命周期结构（Lifecycle Architecture）里程碑。</p><p><strong>构造阶段</strong>——在这一阶段，团队开发出所有的功能集，并有秩序地把功能集成为经过各种测试验证过的产品。构造阶段结束时是第三个重要的里程碑：初始功能（Initial Operational）里程碑。此时的产品版本也常被称为『beta』版。</p><p><strong>交付阶段</strong>——这时候，团队工作的重点是确保软件能满足最终用户的实际需求。交付阶段可以有迭代（beta1，beta2等），团队还要注意处理用户设置、安装和可用性等问题。在交付阶段的终点是第四个里程碑：产品发布（Product Release）里程碑。</p><p><img src="http://file.blog.chaosky.tech/2017-03-07-Snip20170302_5.png" alt="Snip20170302_5"></p><h3 id="渐进交付的流程（Evolutionary-Delivery），MVP-和-MBP"><a href="#渐进交付的流程（Evolutionary-Delivery），MVP-和-MBP" class="headerlink" title="渐进交付的流程（Evolutionary Delivery），MVP 和 MBP"></a>渐进交付的流程（Evolutionary Delivery），MVP 和 MBP</h3><p>当系统的主要需求和架构明确之后，软件团队进入了一个不断演进的 evolution 循环中：</p><p><img src="http://file.blog.chaosky.tech/2017-03-07-Snip20170302_6.png" alt="Snip20170302_6"></p><p>MVP —— Minimal Viable Product，最小可行产品，又称为Minimal Feature Set，最小功能集。</p><p>具体的做法是：把产品最核心的功能用最小的成本实现出来（或者描绘出来），然后快速征求用户意见。例如：一个社交网站已经有很多用户，都是免费的，产品团队想设计一个付费的VIP服务，MVP的做法可以是这样——在目前的用户入口页面中加一个『VIP服务』的链接，指向一个简单的介绍页面。观察到底有多少用户点击这个链接。如果点击量太小，那么这个VIP服务就不用做了。</p><p>MVP的指导思想和渐进交付相似，但是它更强调更早获得用户反馈，为此可以在产品完成之前就发布，它也强调产品的核心价值（产品最区别与竞争产品的地方），为了突出核心功能，别的辅助功能可以不考虑或者用别的平台提供的服务来代替。</p><p>MBP —— Maximal Beautiful Product（最强最美产品）。如果对用户的需求了然于心，或者产品团队比用户更了解用户的需求，为何不把产品最全、最美的形态展现出来，一举征服用户。</p><h3 id="敏捷流程"><a href="#敏捷流程" class="headerlink" title="敏捷流程"></a>敏捷流程</h3><p>现有的做法 VS. 敏捷的做法</p><table><thead><tr><th>现有的做法</th><th>敏捷的做法</th></tr></thead><tbody><tr><td>流程和工具</td><td>个人和交流</td></tr><tr><td>完备的文档</td><td>可用的软件</td></tr><tr><td>为合同谈判</td><td>与客户合作</td></tr><tr><td>执行原定计划</td><td>响应变化</td></tr></tbody></table><h4 id="敏捷软件开发宣言"><a href="#敏捷软件开发宣言" class="headerlink" title="敏捷软件开发宣言"></a>敏捷软件开发宣言</h4><blockquote><p>我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：<br><strong>个体和互动</strong> 高于 流程和工具<br><strong>工作的软件</strong> 高于 详尽的文档<br><strong>客户合作</strong> 高于 合同谈判<br><strong>响应变化</strong> 高于 遵循计划<br>也就是说，尽管右项有其价值，我们更重视左项的价值。</p></blockquote><h4 id="敏捷开发原则"><a href="#敏捷开发原则" class="headerlink" title="敏捷开发原则"></a>敏捷开发原则</h4><ol><li>尽早并持续地交付有价值的软件以满足顾客需求</li><li>敏捷流程欢迎需求的变化，并利用这种变化来提高用户的竞争优势</li><li>经常发布可用的软件，发布间隔可以从几周到几个月，能短则短</li><li>业务人员和开发人员在项目开发过程中应该每天共同工作</li><li>以有进取心的人为项目核心，充分支持信任他们</li><li>无论团队内外，面对面的交流始终最有效的沟通方式</li><li>可用的软件是衡量项目进展的主要指标</li><li>敏捷流程应能保持可持续的发展。领导、团队和用户应该能按照目前的步调持续合作下去</li><li>只有不断关注技术和设计，才能越来越敏捷</li><li>保持简明——尽可能简化工作量的技艺——极为重要</li><li>只有能自我管理的团队才能创建优秀的架构、需求和设计</li><li>时时总结如何提高团队效率，并付诸行动</li></ol><h4 id="Scrum-方法论"><a href="#Scrum-方法论" class="headerlink" title="Scrum 方法论"></a>Scrum 方法论</h4><h5 id="第一步：找出完成产品需要做的事情——Product-Backlog"><a href="#第一步：找出完成产品需要做的事情——Product-Backlog" class="headerlink" title="第一步：找出完成产品需要做的事情——Product Backlog"></a>第一步：找出完成产品需要做的事情——Product Backlog</h5><p>Backlog 翻译成『积压的工作』、『待解决的问题』、『产品订单』，都可以。产品负责人主导大家对于这个 Backlog 进行增/删/改的工作。每一项工作的时间估计单位为『天』。</p><h5 id="第二步：决定当前的冲刺（Sprint）需要解决的事情——Sprint-Backlog。"><a href="#第二步：决定当前的冲刺（Sprint）需要解决的事情——Sprint-Backlog。" class="headerlink" title="第二步：决定当前的冲刺（Sprint）需要解决的事情——Sprint Backlog。"></a>第二步：决定当前的冲刺（Sprint）需要解决的事情——Sprint Backlog。</h5><p>整个产品的实现被划分为几个相互联系的冲刺（Sprint）。产品订单上的任务被进一步细化了，被分解为以小时为单位。如果一个任务的估计时间太长（如超过16个小时），那么它就应该被进一步分解。订单上的任务是团队成员根据自己的情况来认领。团队成员能主导任务的估计和分配，他们的能动性得到较大的发挥。</p><h5 id="第三步：冲刺（Sprint）"><a href="#第三步：冲刺（Sprint）" class="headerlink" title="第三步：冲刺（Sprint）"></a>第三步：冲刺（Sprint）</h5><p>在冲刺阶段，外部人士不能直接打扰团队成员。一切交流只能通过 Scrum 大师（Scrum Master）来完成。这一措施较好地平衡了『交流』和『集中注意力』的矛盾。有任何需求的改变都留待冲刺结束后再讨论。</p><p>冲刺期间，每天要开一个每日例会（Scrum Meeting），团队成员大多站着开会，所以又称<strong>每日立会</strong>。大家依次报告：</p><pre><code>我昨天做了啥我今天要做啥我碰到了哪些问题</code></pre><p>每日立会强迫每个人向同伴报告进度，迫使大家把问题摆在明面上。同时启动每日构建，让大家每天都能看到一个逐渐完善的版本。</p><p>用简明的图表展现整个项目的进度，这个图最好放在大家工作的环境中，或者每天传达给各个成员。</p><p>也可以是简单的看板图：把一堆任务从最初的『待定』推动到『工作中』等各个状态，直至『完成』。</p><p>冲刺阶段是时间驱动的（Time-boxed），时间一到就结束。这个特点看似不起眼，但其实它有效地断了各种延期想法的后路，很高明。</p><h5 id="第四步：得到软件的一个增量版本，发布给用户。然后在此基础上又进一步计划增量的新功能和改进。"><a href="#第四步：得到软件的一个增量版本，发布给用户。然后在此基础上又进一步计划增量的新功能和改进。" class="headerlink" title="第四步：得到软件的一个增量版本，发布给用户。然后在此基础上又进一步计划增量的新功能和改进。"></a>第四步：得到软件的一个增量版本，发布给用户。然后在此基础上又进一步计划增量的新功能和改进。</h5><h4 id="敏捷总结"><a href="#敏捷总结" class="headerlink" title="敏捷总结"></a>敏捷总结</h4><p>敏捷对团队的要求很简单：自主管理（Self-managing）、自我组织（Self-organizing）、多功能型（Cross-functional），但是这很难做到。</p><p>与质量控制理论的模型如经典的戴明环（Plan-Do-Check-Act/Adjust，PDCA）类似。</p><p>Scrum 核心特点：</p><blockquote><p>在迭代开始时，团队审视摆在他们面前的任务，选择他们认为可以在迭代期间完成的那些任务（Plan）。然后团队独立地尽最大努力完成这些任务（Do）。在迭代结束时，团队给利益关系人展示成果（Check），并对开发流程进行调整（Act/Adjust）。</p></blockquote><p>Sprint/Scrum 对项目的众多需求采取分而治之的办法，能让相关人员集中精力，在一定期限内解决部分问题。它强调短时间的迭代（Iteration、Timebox），在多次迭代中不断总结，改进团队的流程和产品功能。他明确地指出不同的人在一个项目中的投入和责任的不同，并坚持让全身心投入的『猪』来主导项目。它通过Daily Scrum、Scrum Master等方法和角色，鼓励团队内部交流，并优化团队和其他人员的交流方式。它对团队成员提出了很高的要求：自主管理、自我组织、多功能型。一般人不能马上做到这一点。它不是『银弹』，不能解决软件开发的所有问题。至于具体项目进度如何跟踪，如何管理测试工作，如何管理复杂项目，还是靠战斗在一线的团队成员见招拆招，想出合适的办法。</p><h5 id="敏捷流程的经验教训"><a href="#敏捷流程的经验教训" class="headerlink" title="敏捷流程的经验教训"></a>敏捷流程的经验教训</h5><ol><li>敏捷宣言表明的是一些优先级，不必当作圣旨或者教条来争论。</li><li>Scrum Master 不是一个官，而是一个没有行政权力的沟通者，就像微软的PM那样。他/她同时还要在团队中做具体的工作。直接把原来的『经理』变成 Scrum Master，大多行不通。</li><li>一些项目需要很多暗箱操作和政治角力才能搞定，Scrum 会把这些矛盾都摆在明处。这有好处，也有风险。</li><li>在复杂的项目里，要让一线团队成员做决定。</li><li>创业公司的团队其实经常是运行在 Scrum 模式中。</li><li>在 Scrum 计划阶段的估计不是一个『合同』，领导们不要把它当成一个合同。估计总是不准的。坚持短期的Sprint，这样即使不准的估计也不会有大的损害。</li><li>不要和管理层谈『流程』，他们只关心『结果』。</li><li>在大型团队、跨地区的团队，或者复杂项目中，Scrum 并没有非常完美的答案，Scrum的创始人也承认这一点。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;软件团队的模式&quot;&gt;&lt;a href=&quot;#软件团队的模式&quot; class=&quot;headerlink&quot; title=&quot;软件团队的模式&quot;&gt;&lt;/a&gt;软件团队的模式&lt;/h2&gt;&lt;h3 id=&quot;主治医师模式（Chief-Programmer-Team，Surgical-Team）&quot;&gt;&lt;a href=&quot;#主治医师模式（Chief-Programmer-Team，Surgical-Team）&quot; class=&quot;headerlink&quot; title=&quot;主治医师模式（Chief Programmer Team，Surgical Team）&quot;&gt;&lt;/a&gt;主治医师模式（Chief Programmer Team，Surgical Team）&lt;/h3&gt;&lt;p&gt;就像在手术台上那样，有一个主刀医师，其他人（麻醉，护士，器械）各司其职，为主刀医师服务。&lt;/p&gt;
&lt;p&gt;这样的软件团队中，有首席程序员（Chief Programmer），他/她负责处理主要模块的设计和编码，其他成员从各种角度支持他/她的工作（后备程序员、系统管理员、工具开发、编程语言专家、业务专家）。&lt;/p&gt;
&lt;p&gt;在一些学校里，软件工程的团队模式往往从这一模式退化为『一个学生干活，其余学生跟着打酱油』。&lt;/p&gt;
&lt;h3 id=&quot;明星模式（Super-star-Model）&quot;&gt;&lt;a href=&quot;#明星模式（Super-star-Model）&quot; class=&quot;headerlink&quot; title=&quot;明星模式（Super-star Model）&quot;&gt;&lt;/a&gt;明星模式（Super-star Model）&lt;/h3&gt;&lt;p&gt;主治医师模式运用到极点，可以蜕化为明星模式，在这里，明星的光芒盖过了团队其他人的总和。明星也是人，也会受伤，犯错误，如何让团队的利益最大化，而不是明星的利益最大化？如何让团队的价值在明星陨落之后任然能够保持？是这个模式要解决的问题。&lt;/p&gt;
&lt;h3 id=&quot;社区模式（Community-Model）&quot;&gt;&lt;a href=&quot;#社区模式（Community-Model）&quot; class=&quot;headerlink&quot; title=&quot;社区模式（Community Model）&quot;&gt;&lt;/a&gt;社区模式（Community Model）&lt;/h3&gt;&lt;p&gt;社区由很多志愿者参与，每个人参与自己感兴趣的项目，贡献力量，大部分人不拿报酬。这种模式的好处是『众人拾柴火焰高』，但是如果大家都只来烤火，不去拾柴；或者捡到的柴火质量太差，最后火也就熄灭了。&lt;strong&gt;『社区』并不意味着『随意』&lt;/strong&gt;，一些成功社区项目（例如开发和维护Linux操作系统的社区），都有很严格的代码复审和签入的质量控制。&lt;/p&gt;
&lt;h3 id=&quot;业余剧团模式（Amateur-Theater-Team）&quot;&gt;&lt;a href=&quot;#业余剧团模式（Amateur-Theater-Team）&quot; class=&quot;headerlink&quot; title=&quot;业余剧团模式（Amateur Theater Team）&quot;&gt;&lt;/a&gt;业余剧团模式（Amateur Theater Team）&lt;/h3&gt;&lt;p&gt;这样的团队在每一个项目中，不同的人会挑选不同的角色。在下一个项目中，这些人也许会换一个完全不同的角色类型。各人在团队中听从一个中央指挥（导演）的指导和安排。在学生实践项目或培训项目中，这样的事情经常发生。&lt;/p&gt;
&lt;h3 id=&quot;秘密团队（Skunk-Work-Team）&quot;&gt;&lt;a href=&quot;#秘密团队（Skunk-Work-Team）&quot; class=&quot;headerlink&quot; title=&quot;秘密团队（Skunk Work Team）&quot;&gt;&lt;/a&gt;秘密团队（Skunk Work Team）&lt;/h3&gt;&lt;p&gt;一些软件项目在秘密状态下进行，别人不知道他们具体在做什么。这种模式的好处是：团队内部有极大的自由，没有外界的干扰（不用每周给别人介绍项目进展，听领导的最新指示，等等），团队成员有极大的投入。&lt;/p&gt;
&lt;h3 id=&quot;特工团队（SWAT）&quot;&gt;&lt;a href=&quot;#特工团队（SWAT）&quot; class=&quot;headerlink&quot; title=&quot;特工团队（SWAT）&quot;&gt;&lt;/a&gt;特工团队（SWAT）&lt;/h3&gt;&lt;p&gt;软件行业的一些团队由一些有特殊技能的专业人士组成，负责解决一些棘手而有紧迫性的问题。&lt;/p&gt;
&lt;h3 id=&quot;交响乐团模式（Orchestra）&quot;&gt;&lt;a href=&quot;#交响乐团模式（Orchestra）&quot; class=&quot;headerlink&quot; title=&quot;交响乐团模式（Orchestra）&quot;&gt;&lt;/a&gt;交响乐团模式（Orchestra）&lt;/h3&gt;&lt;p&gt;想象一下交响乐团的演奏，有下面的特点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;家伙多，门类齐全。&lt;/li&gt;
&lt;li&gt;各司其职，各自有专门场地，演奏期间没有聊天、走动等现象。&lt;/li&gt;
&lt;li&gt;演奏都靠谱，同时看指挥的。&lt;/li&gt;
&lt;li&gt;演奏的都是练习过多次的曲目，重在执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当某个软件领域处于稳定成长阶段的时候，众多大型软件公司的开发团队就会才去这种模式。&lt;/p&gt;
&lt;h3 id=&quot;爵士乐模式（Jazz-Band）&quot;&gt;&lt;a href=&quot;#爵士乐模式（Jazz-Band）&quot; class=&quot;headerlink&quot; title=&quot;爵士乐模式（Jazz Band）&quot;&gt;&lt;/a&gt;爵士乐模式（Jazz Band）&lt;/h3&gt;&lt;p&gt;和交响乐团相比，这种模式有以下特点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不靠谱。他们演奏时都没有谱子。&lt;/li&gt;
&lt;li&gt;没有现场指挥，平时有编曲起到协调和指导作用。&lt;/li&gt;
&lt;li&gt;也有模式，架构师先吹出主题，然后他走到一旁抽烟去了，其余人员根据这个主题各自即兴发挥，最后迈尔斯加入，回应主题，像是对曲子的总结。&lt;/li&gt;
&lt;li&gt;人数较少。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;功能团队模式（Feature-Team）&quot;&gt;&lt;a href=&quot;#功能团队模式（Feature-Team）&quot; class=&quot;headerlink&quot; title=&quot;功能团队模式（Feature Team）&quot;&gt;&lt;/a&gt;功能团队模式（Feature Team）&lt;/h3&gt;&lt;p&gt;很多软件公式的团队最后都演变成功能团队，简而言之，就是具备不同能力的同事们平等协作，共同完成一个功能。&lt;/p&gt;
&lt;p&gt;在这个功能完成之后，这些人又重新组织，和别的角色一起去完成下一个功能。他们之间没有管理和被管理的关系。大型软件公司里的不少团队都是采用这种模式。这些功能小组也称为Feature Crew，小组内的交流比较频繁。&lt;/p&gt;
&lt;p&gt;每个小组都由一到三个人组成，每个小组都是一个有自主权的单元，可以自由选用最有利于他们完成工作的任何技术。但是，每个小组必须与其他小组就编码规范达成一致。&lt;/p&gt;
&lt;h3 id=&quot;官僚模式（Bureaucratic-Model）&quot;&gt;&lt;a href=&quot;#官僚模式（Bureaucratic-Model）&quot; class=&quot;headerlink&quot; title=&quot;官僚模式（Bureaucratic Model）&quot;&gt;&lt;/a&gt;官僚模式（Bureaucratic Model）&lt;/h3&gt;&lt;p&gt;这种模式脱胎于大机构的组织架构，几个人报告给一个小头目，几个小头目报告给中头目，依次而上。这种模式在软件开发中会出问题。因为成员之间不光有技术方面的合作和领导，同时还混进了组织上的领导和被领导关系。跨组织的合作变得比较困难，因为各自头顶上都有不同的老板。&lt;/p&gt;
&lt;p&gt;这种模式如果应用不好，最后会变成『老板驱动』的开发流程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件设计" scheme="http://chaosky.tech/categories/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="开发流程" scheme="http://chaosky.tech/tags/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    
      <category term="团队模式" scheme="http://chaosky.tech/tags/%E5%9B%A2%E9%98%9F%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Xcode 工具链</title>
    <link href="http://chaosky.tech/2017/01/04/Xcode-Toolchain/"/>
    <id>http://chaosky.tech/2017/01/04/Xcode-Toolchain/</id>
    <published>2017-01-04T08:54:40.000Z</published>
    <updated>2020-03-16T07:31:28.340Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>虽然我们来自不同背景、有不同观点，经历不同；虽然我们做事动机不同，信念、偏见和意见使我们彼此分离，有一件事我们是在一起的：</p><p><strong>不管好坏，我们都必须使用 Xcode。</strong></p><p>Xcode 不仅仅只是一个应用程序，在 GUI 之下是一个应用程序和命令行工具的结合，它们与开发人员的工作流程一样是编辑器的核心。</p><a id="more"></a><h2 id="Xcode-Tools"><a href="#Xcode-Tools" class="headerlink" title="Xcode Tools"></a>Xcode Tools</h2><h3 id="xcode-select"><a href="#xcode-select" class="headerlink" title="xcode-select"></a>xcode-select</h3><p>每个人与 Xcode 的旅程从一个选择开始。<code>xcode-select</code>提供了这个选择，尽管是一个永恒的问题：『蛋糕或死亡？』</p><p>从 Mavericks 开始，在 Mac 上的开发者从执行一条命令开始：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcode-<span class="keyword">select</span> <span class="comment">--install</span></span><br></pre></td></tr></table></figure><p>将安装命令行工具，编译 Objective-C 代码必备的。</p><h3 id="xcrun"><a href="#xcrun" class="headerlink" title="xcrun"></a>xcrun</h3><p><code>xcrun</code> 是 Xcode 基本的命令行工具。使用它可以调用其他工具。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>xcrun xcodebuild</span><br></pre></td></tr></table></figure><p>除运行命令之外，<code>xcrun</code> 可以查找文件和显示 SDK 的路径：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">xcrun</span> --<span class="comment">find</span> <span class="comment">clang</span></span><br><span class="line"><span class="comment">$</span> <span class="comment">xcrun</span> --<span class="comment">sdk</span> <span class="comment">iphoneos</span> --<span class="comment">find</span> <span class="comment">pngcrush</span></span><br><span class="line"><span class="comment">$</span> <span class="comment">xcrun</span> --<span class="comment">sdk</span> <span class="comment">macosx</span> --<span class="comment">show</span><span class="literal">-</span><span class="comment">sdk</span><span class="literal">-</span><span class="comment">path</span></span><br></pre></td></tr></table></figure><p>因为 <code>xcrun</code> 的执行是基于当前的 Xcode 版本环境（通过 <code>xcode-select</code>设置），所以在系统中能存在多个版本的 Xcode 工具链是非常容易的。</p><p>在脚本和其他外部工具中使用 <code>xcrun</code> 能确保在不同环境中保证一致性。比如，Xcode 附带了代码分发工具 Git。通过调用 <code>$ xcrun git</code> 而不是 <code>$ git</code>，构建系统可以保证运行正确。</p><h3 id="xcodebuild"><a href="#xcodebuild" class="headerlink" title="xcodebuild"></a>xcodebuild</h3><p>第二个最重要的 Xcode 工具是 <code>xcodebuild</code>，顾名思义，构建 Xcode project 和 workspace。</p><p>不用传递任何构建参数，<code>xcodebuild</code> 默认为 Xcode.app 最近使用的 scheme 和 配置：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>xcodebuild</span><br></pre></td></tr></table></figure><p>然而，任何 scheme、targets、配置、目标设备、SDK和导出数据位置都可以配置：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcodebuild -workspace <span class="module-access"><span class="module"><span class="identifier">NSHipster</span>.</span></span>xcworkspace -scheme <span class="string">"NSHipster"</span></span><br></pre></td></tr></table></figure><p>有六个可以依次调用的构建操作：</p><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>build</td><td>在构建根路径(SYMROOT)构建target。默认构建操作。</td></tr><tr><td>analyze</td><td>在构建根路径(SYMROOT)构建和分析target或者scheme。需要指定 scheme。</td></tr><tr><td>archive</td><td>在构建根路径（SYMROOT）打包 scheme。需要指定 scheme。</td></tr><tr><td>test</td><td>在构建根路径（SYMROOT）测试 scheme。需要指定 scheme和可选指定目标设备。</td></tr><tr><td>installsrc</td><td>拷贝工程源到源根路径（SRCROOT）。</td></tr><tr><td>install</td><td>构建target、安装到target在目标设备根路径（DSTROOT）的安装目录</td></tr><tr><td>clean</td><td>从构建根路径（SYMROOT）移除构建的产品和中间文件</td></tr></tbody></table><h3 id="genstrings"><a href="#genstrings" class="headerlink" title="genstrings"></a>genstrings</h3><p><code>genstrings</code> 工具从指定的C或者Objective-C源文件生成 <code>.strings</code> 文件。在不同的 <code>locale</code> 本地化应用程序使用 <code>.strings</code> 文件。在苹果的 <code>Cocoa Core Competencies</code> 中的 [Internationalization](<a href="https://developer.apple.com/library/mac/documentation/general/conceptual/devpedia-cocoacore/-" target="_blank" rel="noopener">https://developer.apple.com/library/mac/documentation/general/conceptual/devpedia-cocoacore/-</a> Internationalization.html) 有相关的描述。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ genstrings -<span class="keyword">a</span> /path/<span class="built_in">to</span>/source/<span class="built_in">files</span><span class="comment">/*.m</span></span><br></pre></td></tr></table></figure><p>每次在源文件中使用 <code>NSLocalizedString</code>，<code>genstrings</code> 将会追加 <code>key</code> 和 <code>comment</code> 到目标文件中。然后由开发人员为每个目标 locale 创建文件的副本， 并将该文件翻译。</p><p>fr.lproj/Localizable.strings</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* No comment provided by engineer. */</span><br><span class="line"></span><br><span class="line"><span class="string">"Username"</span>=<span class="string">"nom d'utilisateur"</span>;</span><br><span class="line"></span><br><span class="line">/* &#123;<span class="keyword">User</span> <span class="title">First</span> Name&#125;'s Profile */</span><br><span class="line"></span><br><span class="line"><span class="string">"%@'s Profile"</span>=<span class="string">"profil de %1$@"</span>;</span><br></pre></td></tr></table></figure><h3 id="ibtool"><a href="#ibtool" class="headerlink" title="ibtool"></a>ibtool</h3><p>正如 <code>genstrings</code> 作用于源代码，而 <code>ibtool</code> 作用于 <code>XIB</code> 文件。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ibtool --<span class="keyword">generate</span>-strings-file Localizable<span class="variable">.strings</span> en<span class="variable">.lpoj</span>/Interface<span class="variable">.xib</span></span><br></pre></td></tr></table></figure><p>本地化是它的主要功能，<code>ibtool</code> 还拥有对 <code>Interface Builder</code> 文档有效的其他几个功能。</p><ul><li><code>--convert</code>： 更改所有对类名的引用</li><li><code>--upgrade</code>： 将文档升级到最新版</li><li><code>--enable-auto-layout</code>：启用自动布局</li><li><code>--update-frames</code>：更新框架</li><li><code>--update-constraints</code>：更新约束</li></ul><h3 id="iprofiler"><a href="#iprofiler" class="headerlink" title="iprofiler"></a>iprofiler</h3><p><code>iprofiler</code> 测量应用程序的性能，而不启动 <code>Instruments.app</code>：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iprofiler -allocations -leaks -T <span class="number">15</span>s -o perf -a NSHipster</span><br></pre></td></tr></table></figure><p>上面的命令将附加到 NSHipster 程序，运行15秒，分析内存分配和泄露，然后将结果写入perf文件。之后输出结果可以通过 Instruments.app 读取和显示。</p><h3 id="xed"><a href="#xed" class="headerlink" title="xed"></a>xed</h3><p>这个命令可以简单地打开 Xcode。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xed <span class="module-access"><span class="module"><span class="identifier">NSHipster</span>.</span></span>xcworkspace</span><br></pre></td></tr></table></figure><p>通过传递 <code>-w</code> 参数，<code>xed</code> 将等待直到所有打开的窗口关闭。对于脚本化用户交互非常有用，例如提示用户编辑文件并继续一旦完成。</p><h3 id="agvtool"><a href="#agvtool" class="headerlink" title="agvtool"></a>agvtool</h3><p><code>agvtool</code> 用于读取和写入 Xcode工程 Info.plist 中的版本号。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ agvtool what-<span class="built_in">version</span></span><br></pre></td></tr></table></figure><p>返回当前版本</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>agvtool <span class="keyword">next</span>-version</span><br></pre></td></tr></table></figure><p>累加 <code>CURRENT_PROJECT_VERSION</code> 和 <code>DYLIB_CURRENT_VERSION</code>。传递 <code>-all</code> 选项将更新 <code>Info.plist</code> 中的 <code>CFBundleVersion</code>。</p><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><p>除了上述的 Xcode 工具以外，还有一些其他用 <code>xcrun</code> 调用的程序：</p><h3 id="编译-amp-汇编"><a href="#编译-amp-汇编" class="headerlink" title="编译 &amp; 汇编"></a>编译 &amp; 汇编</h3><ul><li><strong>clang</strong>: 编译 C、C++、Objective-C和 Objective-C 源文件。</li><li><strong>lldb</strong>: 调试C、C++、Objective-C 和 Objective-C 程序</li><li><strong>nasm</strong>: 汇编文件</li><li><strong>ndisasm</strong>: 反汇编文件</li><li><strong>symbols</strong>: 显示一个文件或者进程的符号信息。</li><li><strong>strip</strong>: 删除或修改符号表附加到汇编器和链接编辑器的输出。</li><li><strong>atos</strong>: 将数字内存地址转换为二进制映像或进程的符号。</li></ul><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><ul><li><strong>unifdef</strong>: 从代码中移除条件宏 <code>#ifdef</code>。</li><li><strong>ifnames</strong>: 在 C++ 文件中找出所有条件。</li></ul><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><ul><li><strong>ld</strong>: 将目标文件和库合并成一个文件。</li><li><strong>otool</strong>: 显示目标文件或库的指定部分。</li><li><strong>ar</strong>: 创建和维护库文档。</li><li><strong>libtool</strong>: 使用链接器 <code>ld</code> 创建库。</li><li><strong>ranlib</strong>: 更新归档库的目录。</li><li><strong>mksdk</strong>: 创建和更新 SDK。</li><li><strong>lorder</strong>: 列出目标文件的依赖。</li></ul><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><ul><li><strong>sdef</strong>: 脚本定义提取器</li><li><strong>sdp</strong>: 脚本定义处理器</li><li><strong>desdp</strong>: 脚本定义生成器</li><li><strong>amlint</strong>: 检查 Automator 对问题的操作</li></ul><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><ul><li><strong>installer</strong>: 安装 OS X 包。</li><li><strong>pkgutil</strong>: 读取和操纵 OS X 包。</li><li><strong>lsbom</strong>: 列出 bom（Bill of Mterials）内容。</li></ul><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul><li><strong>headerdoc</strong>: 处理头文档。</li><li><strong>gatherheaderdoc</strong>: 编译和链接 <code>headerdoc</code> 输出。</li><li><strong>headerdoc2html</strong>: 从 <code>headerdoc</code> 输出生成 HTML。</li><li><strong>hdxml2manxml</strong>: 从 <code>headerdoc</code> XML 输出翻译成被 <code>xml2man</code> 使用的文件。</li><li><strong>xml2man</strong>: 将 <code>Man Page Generation Language（MPGL）</code> XML文件转换为手册页。</li></ul><h3 id="Core-Data"><a href="#Core-Data" class="headerlink" title="Core Data"></a>Core Data</h3><ul><li><strong>momc</strong>: 编译 <code>Managed Object Model(.mom)</code>文件</li><li><strong>mapc</strong>: 编译 <code>Core Data Mapping Model(.xcmappingmodel)</code>文件</li></ul><h2 id="第三方工具"><a href="#第三方工具" class="headerlink" title="第三方工具"></a>第三方工具</h2><h3 id="appledoc"><a href="#appledoc" class="headerlink" title="appledoc"></a>appledoc</h3><p>Cocoa 开发人员认为 Objective-C 的冗长有助于自注释代码。在 <code>longMethodNamesWithNamedParameters:</code> 和 明确的参数类型。Objective-C 方法不会留下太多的想象力。</p><p>但是即使自注释代码也可以通过文档来改进，只用少量的努力就能够对他人产生显著的益处。</p><p>在 Objective-C 中，选择的文档工具是 <code>appledoc</code>。使用 <code>javadoc</code> 类似的语法，<code>appledoc</code> 能够从 .h文件生成 HTML 和 Xcode 兼容的 .docset 文档，看起来几乎和苹果官方文档完全相同。</p><p>Objective-C 文档由任何 <code>@interface</code> 或 <code>@protocol</code> 之前的 <code>/** */</code> 注释块（注意额外的初始星号）以及任何方法或 <code>@property</code> 声明指定。文档还可能包含系统字段的标签，如参数或返回值：</p><ul><li><strong>@param [param] [Description]</strong>: 描述应传递什么值或此参数</li><li><strong>@return [Description]</strong>: 描述方法的返回值</li><li><strong>@see [selector]</strong>: 提供 『参见』相关项目的参考</li><li><strong>@discussion [Discussion]</strong>: 提供额外的背景资料</li><li><strong>@warning [Description]</strong>: 调用异常或潜在的危险行为</li></ul><p><code>appledoc</code> 可以通过以下命令安装：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">brew </span><span class="keyword">install </span>appledoc</span><br></pre></td></tr></table></figure><p>要生成文档，需要在 Xcode 工程的根目录下执行 <code>appledoc</code> 命令，传递元数据比如工程名和公司名：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ appledoc <span class="params">--project-name</span> CFHipsterRef <span class="params">--project-company</span> <span class="string">"NSHipster"</span> <span class="params">--company-id</span> com.nshipster <span class="params">--output</span> ~<span class="string">/Documents</span> .</span><br></pre></td></tr></table></figure><p>从目标目录中找到的头文件中生成并安装一个Xcode .docset文件。</p><p>通过传递 <code>--help</code> 参数可以找到其他配置选项（包括HTML输出）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> appledoc --<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure><h3 id="xctool"><a href="#xctool" class="headerlink" title="xctool"></a>xctool</h3><p>它可以直接替代 xcodebuild，也就是 Xcode.app 自己所依赖的底层工具。</p><p>我们自己作为苹果硬件和软件的消费者，都清楚设计的重要性怎么强调都不为过。在这个方面，xctool 做得非常漂亮。构建过程的每一步都经过清晰的组织，使用 ANSI 彩色字符和一系列 Unicode 装饰字符，使得表现的方式既容易理解又具有视觉吸引力，同时 xctool 的美丽不仅仅体现了表面：构建过程同样支持以其他工具可读取的格式进行输出：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>xctool -reporter <span class="symbol">plain:</span>output.txt build</span><br></pre></td></tr></table></figure><ul><li><strong>pretty</strong>: (默认) 一个文字化的输出器，使用 ANSI 颜色和 unicode 符号来进行美化输出。</li><li><strong>plain</strong>: 类似 pretty, 不过没有颜色和 Unicode。</li><li><strong>phabricator</strong>: 把构建/测试的结果输出为 JSON 数组，它可以被 Phabricator 的代码评审工具读取。</li><li><strong>junit</strong>: 把测试结果输出成和 JUnit/xUnit 兼容的 XML 文件。</li><li><strong>json-stream</strong>: 一个由构建/测试事件组成的 JSON 字典流，每行一个（示例输出）。</li><li><strong>json-compilation-database</strong>: 输出构建事件的 JSON Compilation Database ，它可以用于基于 Clang Tooling 的工具，例如 OCLint.</li></ul><p>xctool 相对于 xcodebuild 另一个主要的进步是，xctool 可以和 Xcode.app 一样执行应用测试（xcodebuild 不能区分项目 scheme 中哪些是测试使用的 target，更不用说在模拟器中执行测试了）。</p><p>仅仅因为这一个原因，xctool 就深刻地影响了 Objective-C 社区中新兴的持续集成测试的规范。</p><p>通过以下命令安装 <code>xctool</code>：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">brew </span><span class="keyword">install </span>xctool</span><br></pre></td></tr></table></figure><h3 id="OCLint"><a href="#OCLint" class="headerlink" title="OCLint"></a>OCLint</h3><p>OCLint 是一个静态代码分析工具，可以检查 Objective-C（也支持 C 和 C++）代码中常见的问题，例如空的 if/else/try/catch/finally 语句，未使用的本地变量和参数，大量复杂的没有注释的(NCSS)，具有圈复杂度或者 NPath 复杂度的代码，冗余的代码，代码“异味”，以及其他的不好的代码实践。</p><p>安装 OCLint 最好的方式是通过 Homebrew Cask:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">brew </span>cask <span class="keyword">install </span>oclint</span><br></pre></td></tr></table></figure><p>还记得 <code>xctool</code> 的 <code>json-compilation-database</code> 输出选项吗？它的输出可以直接 被 <code>OCLint</code> 读取，供它进行魔法一般的静态分析。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ xctool -workspace NSHipster.xcworkspace -scheme "NSHipster" -reporter <span class="type">json</span>-compilation-<span class="keyword">database</span> build &gt; compile_commands.json</span><br><span class="line"></span><br><span class="line">$ oclint-<span class="type">json</span>-compilation-<span class="keyword">database</span></span><br></pre></td></tr></table></figure><h3 id="xcpretty"><a href="#xcpretty" class="headerlink" title="xcpretty"></a>xcpretty</h3><p><code>xcpretty</code> 类似于 <code>xctool</code>，改进了 <code>xcodebuild</code> 的构建输出，但是 <code>xcpretty</code> 不是尝试替换 <code>xcodebuild</code>，而是扩展并改进它。</p><p>实际上，xcpretty 通过获取 xcodebuild 的管道输出而不是直接调用，充分体现了 Unix的可组合性理念：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcodebuild [flags] <span class="string">| xcpretty -c</span></span><br></pre></td></tr></table></figure><p>这种方法的一个主要好处是它真的很快——事实上，在某些情况下，xcpretty 实际上比直接调用 xcodebuild 快一点，因为它节省了打印到控制台的时间。</p><p>与 xctool 的另一个共性是报告器功能，其具有格式化输出到JUnit风格的XML、HTML或上述OCTool 兼容的 json编译数据库格式。</p><p>xcpretty 通过 RubyGems 安装：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem <span class="keyword">install</span> xcpretty</span><br></pre></td></tr></table></figure><h3 id="Nomad"><a href="#Nomad" class="headerlink" title="Nomad"></a>Nomad</h3><p><code>Nomad</code> 是用于 iOS 和 OS X 开发的世界级命令行实用程序的集合。它自动化常见的管理任务，以便开发人员可以专注于构建和传输软件。</p><p>每个工具可以单独安装，也可以一起安装：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install nomad-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure><h4 id="Cupertino"><a href="#Cupertino" class="headerlink" title="Cupertino"></a>Cupertino</h4><p>应用程序 Provisioning 流程普遍被苹果开发人员厌恶。</p><p>除了整个过程是一个从开始到完成的噩梦，许多操作需要通过 Web 界面进行交互。不仅需要大量的额外点击，但使得它非常不自动化。</p><p><code>Cupertino</code> 提供一个命令行工具管理设备、provisioning proﬁle、app ID 和证书。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ ios devices:list</span><br><span class="line"></span><br><span class="line">+------------------------------+---------------------------------------+</span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line"><span class="string">Listing 2 devices. You can register 98 additional devices.</span></span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">+---------------------------+------------------------------------------+</span><br><span class="line"></span><br><span class="line">|<span class="string"> Device Name</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> Device Identifier</span></span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">+---------------------------+------------------------------------------+</span><br><span class="line"></span><br><span class="line">|<span class="string"> Johnny Appleseed iPad</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> 0123456789012345678901234567890123abcdef </span>|</span><br><span class="line"></span><br><span class="line">|<span class="string"> Johnny Appleseed iPhone</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> abcdef0123456789012345678901234567890123 </span>|</span><br><span class="line"></span><br><span class="line">+---------------------------+------------------------------------------+</span><br><span class="line"></span><br><span class="line">$ ios devices:add <span class="string">"iPad 1"</span>=abc123</span><br><span class="line"></span><br><span class="line">$ ios devices:add <span class="string">"iPad 2"</span>=def456 <span class="string">"iPad 3"</span>=ghi789 ...</span><br></pre></td></tr></table></figure><p>通过以下命令单独安装：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem <span class="keyword">install</span> cupertino</span><br></pre></td></tr></table></figure><h4 id="Shenzhen"><a href="#Shenzhen" class="headerlink" title="Shenzhen"></a>Shenzhen</h4><p>Web 开发人员在 iOS 上的对应部分是能够在几秒钟内持续部署代码，而不是等待几天 Capertino 批准（有时拒绝！）更新。</p><p>幸运的是，一个围绕着开发和企业分发的新兴产业已经兴起。第三方服务像 HockeyApp、DeployGate 和 TestFlight 提供给开发者更容易的范式注册测试用户和发送最新构建给QA。</p><p><code>Shenzhen</code> 是进一步自动化此过程的工具，通过构建 .ipa文件，然后发布到 FTP/SFTP服务器、S3 存储或者其他任何上述第三方服务。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /path/<span class="keyword">to</span>/iOS Project/</span><br><span class="line">$ ipa build</span><br><span class="line">$ ipa distribute:sftp --host HOST -u<span class="built_in"> USER </span>-p PASSWORD -P FTP_PATH</span><br></pre></td></tr></table></figure><h4 id="Houston"><a href="#Houston" class="headerlink" title="Houston"></a>Houston</h4><p><code>Houston</code> 是一个简单的工具发送苹果推送通知。传递凭据、构造消息并将其发送到设备。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apn push <span class="string">"&lt;token&gt;"</span> -<span class="keyword">c</span> /path/<span class="keyword">to</span>/apple_push_notification.pem -m <span class="string">"Hello from the command line!"</span></span><br></pre></td></tr></table></figure><p>这个工具对测试远程推送非常有用——尤其是在新应用中实现该功能。</p><h4 id="Venice"><a href="#Venice" class="headerlink" title="Venice"></a>Venice</h4><p>不管怎样应用内购买已经成为app开发者最有利的商业模式。有了这么多，对某人的生活而言确保这些购买的有效性是首要的。</p><p><code>Venice</code> 是一个命令行程序，用于验证 Apple 应用内购买收据，并检索与收据数据相关的信息。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">$ iap verify /path/to/receipt</span><br><span class="line">+-----------------------------+-------------------------------+</span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line"><span class="string">Receipt</span></span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">+-----------------------------+-------------------------------+</span><br><span class="line"></span><br><span class="line">|<span class="string"> app_item_id</span></span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">|<span class="string"> bid</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> com.foo.bar</span></span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">|<span class="string"> bvrs</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> 20120427</span></span><br><span class="line"></span><br><span class="line">|</span><br><span class="line">|<span class="string"> original_purchase_date</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> Sun, 01 Jan 2013 12:00:00 GMT </span>|</span><br><span class="line"></span><br><span class="line">|<span class="string"> original_transaction_id</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> 1000000000000001</span></span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">|<span class="string"> product_id</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> com.example.product</span></span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">|<span class="string"> purchase_date</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> Sun, 01 Jan 2013 12:00:00 GMT </span>|</span><br><span class="line"></span><br><span class="line">|<span class="string"> quantity</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> 1</span></span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">|<span class="string"> transaction_id</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> 1000000000000001</span></span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">|<span class="string"> version_external_identifier </span>|</span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line"><span class="string">+-----------------------------+-------------------------------+</span></span><br></pre></td></tr></table></figure><p>像 <code>Houston</code>、<code>Venice</code>有一个客户端库组件，允许它部署在 Rails或 Sinatra应用程序上。验证服务器上的收据允许保留他们自己的过去购买记录，这对于最新的指标和历史分析是有用的。因此，任何人关于IAP需要认真对待是推荐的做法。</p><h4 id="Dubai"><a href="#Dubai" class="headerlink" title="Dubai"></a>Dubai</h4><p>Passbook 管理登机牌、电影票、零售优惠券和会员卡。使用 PassKit API，开发人员可以注册 Web 服务自动更新 Passbook的内容，例如登机牌上的登机口更改或会员卡添加积分。</p><p><code>Dubai</code>可以很容易地从脚本或命令行生成 .pkpass 文件，允许快速迭代你的 pass 的设计和内容，或者在空中生成一次性的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pk <span class="keyword">generate</span> Example<span class="variable">.pass</span> -T boarding-pass</span><br></pre></td></tr></table></figure><p>一旦生成了通行证，它可以用 <code>Dubai</code> 创建本地 HTTP 服务，允许通行证在 iOS 模拟器中实时预览：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pk serve <span class="module-access"><span class="module"><span class="identifier">Example</span>.</span></span>pass -c /path/<span class="keyword">to</span>/certificate.p12</span><br><span class="line">$ <span class="keyword">open</span> http:<span class="comment">//localhost:4567/pass.pkpass</span></span><br></pre></td></tr></table></figure><h3 id="Fastlane"><a href="#Fastlane" class="headerlink" title="Fastlane"></a>Fastlane</h3><p>fastlane 是一套自动化打包的工具集，用 Ruby 写的，用于 iOS 和 Android 的自动化打包和发布等工具。gym 是其中的打包命令。</p><p>官网：<a href="https://fastlane.tools" target="_blank" rel="noopener">https://fastlane.tools</a></p><p>GitHub：<a href="https://github.com/fastlane/fastlane" target="_blank" rel="noopener">https://github.com/fastlane/fastlane</a></p><p>fastlane 包含了我们日常编码之后要上线时候进行操作的所有命令。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">deliver:</span> 上传屏幕截图、二进制程序数据和应用程序到AppStore</span><br><span class="line"><span class="symbol">snapshot:</span> 自动截取你的程序在每个设备上的图片</span><br><span class="line"><span class="symbol">frameit:</span> 应用截屏外添加设备框架</span><br><span class="line"><span class="symbol">pem:</span> 可以自动化地生成和更新应用推送通知描述文件</span><br><span class="line"><span class="symbol">sigh:</span> 生成下载开发商店的配置文件</span><br><span class="line"><span class="symbol">produce:</span> 利用命令行在 iTunes Connect 创建一个新的 iOS app</span><br><span class="line"><span class="symbol">cert:</span> 自动创建 iOS 证书</span><br><span class="line"><span class="symbol">pilot:</span> 最好的在终端管理测试和建立的文件</span><br><span class="line"><span class="symbol">boarding:</span> 很容易的方式邀请beta测试</span><br><span class="line"><span class="symbol">gym:</span> 建立新的发布的版本，打包</span><br><span class="line"><span class="symbol">match:</span> 使用git同步你成员间的开发者证书和文件配置</span><br><span class="line"><span class="symbol">scan:</span> 在iOS 和Mac app 上执行测试用例</span><br></pre></td></tr></table></figure><p>一个完整的发布过程可以用 fastlane描述成下面这样：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lane <span class="symbol">:appstore</span> <span class="keyword">do</span></span><br><span class="line">increment_build_number</span><br><span class="line">cocoapods</span><br><span class="line">xctool</span><br><span class="line">snapshot</span><br><span class="line">sigh</span><br><span class="line">deliver</span><br><span class="line">frameit</span><br><span class="line">sh <span class="string">"./customScript.sh"</span></span><br><span class="line">Slack</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol><li>提高版本号</li><li>cocoapods 进行相关pod配置</li><li>xctool 进行编译</li><li>snapshot 自动生成截图</li><li>sigh 处理 provision profile 相关的事情</li><li>deliver 上传截图</li><li>frameit 将应用截图快速的放入对应的设备尺寸中</li><li>执行一些自动化的脚本</li><li>把结果发送到 slack</li></ol><p>这是一个完成的自动化的过程。不过实际发布过程中，截图那部分笔者所在公司还是自己手动上传了，fastlane基本还是用来自动化打包。</p><p><img src="http://file.blog.chaosky.tech/2017-03-07-intro-fastlane-tree.png" alt="intro-fastlane-tree"><br>安装fastlane</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem <span class="keyword">install</span> fastlane</span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在项目根目录下，初始化Fastlane:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>fastlane init</span><br></pre></td></tr></table></figure><p>初始化的过程中会要求填写一些项目信息比如 Apple ID, fastlane 会自动检测当前目录中项目的App Name和App Identifier。如果检测的不对，选择 n 自行输入。同时会在项目中生成一个fastlane的文件夹。</p><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">fastlane</span></span><br><span class="line">├── <span class="selector-tag">Appfile</span></span><br><span class="line">├── <span class="selector-tag">Deliverfile</span></span><br><span class="line">├── <span class="selector-tag">Fastfile</span></span><br><span class="line">├── <span class="selector-tag">metadata</span></span><br><span class="line">│   ├── <span class="selector-tag">app_icon</span><span class="selector-class">.jpg</span></span><br><span class="line">│   ├── <span class="selector-tag">copyright</span><span class="selector-class">.txt</span></span><br><span class="line">│   ├── <span class="selector-tag">primary_category</span><span class="selector-class">.txt</span></span><br><span class="line">│   ├── <span class="selector-tag">primary_first_sub_category</span><span class="selector-class">.txt</span></span><br><span class="line">│   ├── <span class="selector-tag">primary_second_sub_category</span><span class="selector-class">.txt</span></span><br><span class="line">│   ├── <span class="selector-tag">review_information</span></span><br><span class="line">│   │   ├── <span class="selector-tag">demo_password</span><span class="selector-class">.txt</span></span><br><span class="line">│   │   ├── <span class="selector-tag">demo_user</span><span class="selector-class">.txt</span></span><br><span class="line">│   │   ├── <span class="selector-tag">email_address</span><span class="selector-class">.txt</span></span><br><span class="line">│   │   ├── <span class="selector-tag">first_name</span><span class="selector-class">.txt</span></span><br><span class="line">│   │   ├── <span class="selector-tag">last_name</span><span class="selector-class">.txt</span></span><br><span class="line">│   │   ├── <span class="selector-tag">notes</span><span class="selector-class">.txt</span></span><br><span class="line">│   │   └── <span class="selector-tag">phone_number</span><span class="selector-class">.txt</span></span><br><span class="line">│   ├── <span class="selector-tag">secondary_category</span><span class="selector-class">.txt</span></span><br><span class="line">│   ├── <span class="selector-tag">secondary_first_sub_category</span><span class="selector-class">.txt</span></span><br><span class="line">│   ├── <span class="selector-tag">secondary_second_sub_category</span><span class="selector-class">.txt</span></span><br><span class="line">│   └── <span class="selector-tag">zh-Hans</span></span><br><span class="line">│       ├── <span class="selector-tag">description</span><span class="selector-class">.txt</span></span><br><span class="line">│       ├── <span class="selector-tag">keywords</span><span class="selector-class">.txt</span></span><br><span class="line">│       ├── <span class="selector-tag">marketing_url</span><span class="selector-class">.txt</span></span><br><span class="line">│       ├── <span class="selector-tag">name</span><span class="selector-class">.txt</span></span><br><span class="line">│       ├── <span class="selector-tag">privacy_url</span><span class="selector-class">.txt</span></span><br><span class="line">│       ├── <span class="selector-tag">release_notes</span><span class="selector-class">.txt</span></span><br><span class="line">│       └── <span class="selector-tag">support_url</span><span class="selector-class">.txt</span></span><br><span class="line">└── <span class="selector-tag">screenshots</span></span><br><span class="line">    ├── <span class="selector-tag">README</span><span class="selector-class">.txt</span></span><br><span class="line">    └── <span class="selector-tag">zh-Hans</span></span><br><span class="line">        ├── 1_<span class="selector-tag">iphone6Plus_1</span><span class="selector-class">.6</span>+ <span class="selector-tag">Screenshot</span> 0 <span class="selector-tag">iPhone</span><span class="selector-class">.png</span></span><br><span class="line">        ├── 2_<span class="selector-tag">iphone6Plus_2</span><span class="selector-class">.6</span>+ <span class="selector-tag">Screenshot</span> 1 <span class="selector-tag">iPhone</span><span class="selector-class">.png</span></span><br><span class="line">        ├── 3_<span class="selector-tag">iphone6Plus_3</span><span class="selector-class">.6</span>+ <span class="selector-tag">Screenshot</span> 4 <span class="selector-tag">iPhone</span><span class="selector-class">.png</span></span><br><span class="line">        ├── 4_<span class="selector-tag">iphone6Plus_4</span><span class="selector-class">.6</span>+ <span class="selector-tag">Screenshot</span> 2 <span class="selector-tag">iPhone</span><span class="selector-class">.png</span></span><br><span class="line">        └── 5_<span class="selector-tag">iphone6Plus_5</span><span class="selector-class">.6</span>+ <span class="selector-tag">Screenshot</span> 3 <span class="selector-tag">iPhone</span><span class="selector-class">.png</span></span><br></pre></td></tr></table></figure><p>上面这些文件中，最重要的两个文件就是Appfile和Fastfile。</p><p>Appfile 里面存放了App的基本信息包括app_identifier、apple_id、team_id。如果在init的时候你输入了正确的appId账号和密码会在这里生成正确的team_id信息。如果没有team，这里就不会显示。</p><p>Fastfile是最重要的一个文件，在这个文件里面可以编写和定制我们打包脚本的一个文件，所有自定义的功能都写在这里。</p><p>如果在init的时候选择了在iTunes Connect创建App，那么fastlane会调用produce进行初始化，如果现在还不想创建，也可以之后再运行produce init进行这个流程。如果不执行produce的流程，deliver的流程不会被执行，当然之后也可以deliver init运行完全一样的流程。</p><p>在iTunes Connect 中成功创建App之后，fastlane的文件夹里面就有Deliverfile文件了。</p><p>Deliverfile文件里面主要是deliver的配置文件和Deliverfile的一些帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h2&gt;&lt;p&gt;虽然我们来自不同背景、有不同观点，经历不同；虽然我们做事动机不同，信念、偏见和意见使我们彼此分离，有一件事我们是在一起的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不管好坏，我们都必须使用 Xcode。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Xcode 不仅仅只是一个应用程序，在 GUI 之下是一个应用程序和命令行工具的结合，它们与开发人员的工作流程一样是编辑器的核心。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosky.tech/categories/iOS/"/>
    
    
      <category term="Xcode" scheme="http://chaosky.tech/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>iOS vs Android</title>
    <link href="http://chaosky.tech/2016/12/30/iOS-vs-Android/"/>
    <id>http://chaosky.tech/2016/12/30/iOS-vs-Android/</id>
    <published>2016-12-30T11:05:56.000Z</published>
    <updated>2020-03-16T07:31:28.339Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><p>iOS系统分为可分为四级结构，由上至下分别为可触摸层（Cocoa Touch Layer）、媒体层（Media Layer）、核心服务层（Core Services Layer）、核心系统层（Core OS Layer），每个层级提供不同的服务。低层级结构提供基础服务如文件系统、内存管理、I/O操作等。高层级结构建立在低层级结构之上提供具体服务如UI控件、文件访问等。<br><img src="http://file.blog.chaosky.tech/2016-12-30-797918-71efb73f5f3ab3c6.png" alt="797918-71efb73f5f3ab3"></p><h4 id="可触摸层（Cocoa-Touch-Layer）"><a href="#可触摸层（Cocoa-Touch-Layer）" class="headerlink" title="可触摸层（Cocoa Touch Layer）"></a>可触摸层（Cocoa Touch Layer）</h4><p>可触摸层主要提供用户交互相关的服务如界面控件、事件管理、通知中心、地图，包含以下框架：</p><ul><li>UIKit（界面相关）</li><li>EventKit（日历事件提醒等）</li><li>Notification Center（通知中心）</li><li>MapKit（地图显示）</li><li>Address Book（联系人）</li><li>iAd（广告）</li><li>Message UI（邮件与SMS显示）</li><li>PushKit（iOS8新push机制）<br><img src="http://file.blog.chaosky.tech/2016-12-30-797918-486bd1393e7d908a.jpg" alt="797918-486bd1393e7d908a"></li></ul><h4 id="媒体层（Media-Layer）"><a href="#媒体层（Media-Layer）" class="headerlink" title="媒体层（Media Layer）"></a>媒体层（Media Layer）</h4><p>媒体层主要提供图像引擎、音频引擎、视频引擎框架。</p><ul><li>图像引擎（Core Graphics、Core Image、Core Animation、OpenGL ES）</li><li>音频引擎 （Core Audio、 AV Foundation、OpenAL）</li><li>视频引擎（AV Foundation、Core Media）<br><img src="http://file.blog.chaosky.tech/2016-12-30-797918-30e2f3470787b368.jpg" alt="797918-30e2f3470787b368"></li></ul><h4 id="核心服务层（Core-Services-Layer）"><a href="#核心服务层（Core-Services-Layer）" class="headerlink" title="核心服务层（Core Services Layer）"></a>核心服务层（Core Services Layer）</h4><p>核心服务层为程序提供基础的系统服务例如网络访问、浏览器引擎、定位、文件访问、数据库访问等，主要包含以下框架：</p><ul><li>CFNetwork（网络访问）</li><li>Core Data（数据存储）</li><li>Core Location（定位功能）</li><li>Core Motion（重力加速度，陀螺仪）</li><li>Foundation（基础功能如NSString）</li><li>Webkit（浏览器引擎）</li><li>JavaScript（JavaScript引擎）<br><img src="http://file.blog.chaosky.tech/2016-12-30-797918-cc0de0f6f45ff252.jpg" alt="797918-cc0de0f6f45ff252"></li></ul><h4 id="核心系统层（Core-OS-Layer）"><a href="#核心系统层（Core-OS-Layer）" class="headerlink" title="核心系统层（Core OS Layer）"></a>核心系统层（Core OS Layer）</h4><p>核心系统层提供为上层结构提供最基础的服务如操作系统内核服务、本地认证、安全、加速等。</p><ul><li>操作系统内核服务（BSD sockets、I/O访问、内存申请、文件系统、数学计算等）</li><li>本地认证（指纹识别验证等）</li><li>安全（提供管理证书、公钥、密钥等的接口）</li><li>加速 (执行数学、大数字以及DSP运算,这些接口iOS设备硬件相匹配）<br><img src="http://file.blog.chaosky.tech/2016-12-30-797918-2965748e8e244c2e.jpg" alt="797918-2965748e8e244c2e"></li></ul><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>Andorid 大致可以分为四层结构：应用层、应用框架层、系统运行库层、Linux内核层。<br><img src="http://file.blog.chaosky.tech/2016-12-30-20140311140541765.jpeg" alt="20140311140541765"></p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等程序，或者是你从 Google Play 上下载的小游戏，当然还包括你自己开发的程序。</p><h4 id="应用框架层"><a href="#应用框架层" class="headerlink" title="应用框架层"></a>应用框架层</h4><p>这一层主要提供了构建应用程序时可能用到的各种 API，Android 自带的一些核心应用就是使用这些 API 完成的，开发者也可以通过使用这些 API 来构建自己的应用程序。</p><h4 id="系统运行库层"><a href="#系统运行库层" class="headerlink" title="系统运行库层"></a>系统运行库层</h4><p>这一层通过一些 C/C++ 库来为 Android 系统提供了主要的特性支持。如 SQLite 库提供了数据库的支持，OpenGL|ES 库提供了 3D 绘图的支持，WebKit 库提供了浏览器内核的支持等。</p><h4 id="Linux-内核层"><a href="#Linux-内核层" class="headerlink" title="Linux 内核层"></a>Linux 内核层</h4><p>Android 系统是基于 Linux 内核的，这一层为 Android 设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi 驱动、电源管理等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cydia 源 和 插件</title>
    <link href="http://chaosky.tech/2016/12/07/Cydia-Sources-and-Tweaks/"/>
    <id>http://chaosky.tech/2016/12/07/Cydia-Sources-and-Tweaks/</id>
    <published>2016-12-07T03:52:20.000Z</published>
    <updated>2020-03-16T07:31:28.338Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Cydia-源"><a href="#Cydia-源" class="headerlink" title="Cydia 源"></a>Cydia 源</h2><ol><li>JBnow Repo <a href="http://repo.jbnow.me/" target="_blank" rel="noopener">http://repo.jbnow.me/</a></li><li>BigBoss Repo <a href="http://apt.thebigboss.org/repofiles/cydia/" target="_blank" rel="noopener">http://apt.thebigboss.org/repofiles/cydia/</a></li><li>ModMyi Repo <a href="http://apt.modmyi.com/" target="_blank" rel="noopener">http://apt.modmyi.com/</a></li><li>BiteYourApple Repo <a href="http://repo.biteyourapple.net/" target="_blank" rel="noopener">http://repo.biteyourapple.net/</a></li><li>filippoBiga <a href="http://filippobiga.me/repo/" target="_blank" rel="noopener">http://filippobiga.me/repo/</a></li><li>SINful iPhone Rep <a href="http://sinfuliphonerepo.com/" target="_blank" rel="noopener">http://sinfuliphonerepo.com/</a> </li><li>ihacksrepo <a href="http://ihacksrepo.com/" target="_blank" rel="noopener">http://ihacksrepo.com/</a></li><li>iNsanelyi Repo <a href="http://repo.insanelyi.com" target="_blank" rel="noopener">http://repo.insanelyi.com</a></li><li>iHackStore Repo <a href="http://ihackstore.com/repo" target="_blank" rel="noopener">http://ihackstore.com/repo</a></li><li>SinfuliPhone Repo <a href="http://sinfuliphonerepo.com/" target="_blank" rel="noopener">http://sinfuliphonerepo.com/</a></li><li>iPhoneCake Repo <a href="http://cydia.iphonecake.com" target="_blank" rel="noopener">http://cydia.iphonecake.com</a></li><li>威锋源 <a href="http://apt.so/" target="_blank" rel="noopener">http://apt.so/</a></li><li>PP助手源 <a href="http://apt.25pp.com/" target="_blank" rel="noopener">http://apt.25pp.com/</a></li><li>IAPCrazy <a href="http://apt.youyuanapp.com" target="_blank" rel="noopener">http://apt.youyuanapp.com</a></li><li>小白源 <a href="http://apt.xbyy.cn" target="_blank" rel="noopener">http://apt.xbyy.cn</a></li></ol><a id="more"></a><h2 id="100-免费的越狱插件"><a href="#100-免费的越狱插件" class="headerlink" title="100 免费的越狱插件"></a>100 免费的越狱插件</h2><ul><li>20 Second Lockscreen</li><li>3DNoLag</li><li>DeleteForever</li><li>Alkaline</li><li>AlwaysMore For Spotlight</li><li>Appendix</li><li>Apple File Conduit “2”</li><li>Cuttlefish</li><li>Bars</li><li>BerryC8</li><li>BetterFiveColumnHomescreen</li><li>BetterFiveIconDock</li><li>Bloard</li><li>BlurryBadges</li><li>Cream</li><li>BreadcrumbsAway</li><li>Browser Changer</li><li>BytaFont 3</li><li>CCDeseparator</li><li>CCColor</li><li>CCloader</li><li>CCMeters</li><li>CCircle</li><li>CircleIcons</li><li>CCBackground</li><li>Cylinder</li><li>DetailedBatteryUsage</li><li>Ethos</li><li>FaceDown</li><li>CCSettings</li><li>FlatSafariURL</li><li>GlowBadge</li><li>Goodges</li><li>GrabberApp8</li><li>HotDog</li><li>IconBounce</li><li>Incognito Messages</li><li>Instabetter</li><li>Activator</li><li>LockGlyph</li><li>MTerminal</li><li>Messages Customiser</li><li>MinimalHUD</li><li>Mobius</li><li>SpotlightBeGone</li><li>MultiIconMover</li><li>NCReveal9</li><li>NCIfNeeded</li><li>NoAppStoreRedirect</li><li>PM, Really?</li><li>PhoneAppNoFav</li><li>RePower</li><li>PowerTap</li><li>PriorityHUB</li><li>PullToRespring</li><li>SafariTabCount</li><li>SafariCloseAllTabs</li><li>SmoothCursor</li><li>Speed Intensifier</li><li>RomanPasscode</li><li>SendDelay</li><li>StatusBarColor</li><li>StatusBarTimer</li><li>StatusModifier</li><li>ReturnToSender</li><li>RoundDock</li><li>SwipeSelection</li><li>SwipeForMore</li><li>Tactful</li><li>VintageSwitcher</li><li>Zeppelin</li><li>Folder6Plus</li><li>FullFolder9</li><li>IconArt</li><li>AppColorClose</li><li>Floater</li><li>FlashRing</li><li>IconRenamer</li><li>NCColor</li><li>Tintch</li><li>Record ‘n Torch</li><li>TapTapFlip</li><li>Wink</li><li>TransparentDock</li><li>Unlock Sound</li><li>BottomBar</li><li>Cask</li><li>SwipyFolders</li><li>iCleaner</li><li>SafariRefresh</li><li>SpinSettings</li><li>KeyboardVibrate8</li><li>Harbor</li></ul><h2 id="开发必备越狱插件"><a href="#开发必备越狱插件" class="headerlink" title="开发必备越狱插件"></a>开发必备越狱插件</h2><ul><li><strong>Apple File Conduit “2”</strong>: allow full file-system access over USB</li><li><strong>AppList</strong>: Allow extensions to read the list of installed apps</li><li><strong>Appsync</strong>: Appsync 允许安装AppStore 以外的应用到设备的补丁。</li><li><strong>Cydia Substrate</strong>: powerful code insertion platform</li><li><strong>Flipboard FLEX Loader</strong>: dynamically loads Flipboard Explorer into apps</li><li><strong>IAPCrazy</strong>: 内购神器</li><li><strong>iFile</strong>: 文件管理器</li><li><strong>tsProtector 8+(iOS 9 &amp; 8)</strong>: protect system from subspicious apps</li><li><strong>Cycript</strong>: runtime execution server and disassembler</li><li><strong>Reveal Loader</strong>: dynamically loads Reveal into applications</li><li><strong>OpenSSH</strong>: secure remote access between machines</li><li><strong>MTerminal</strong>: 终端</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Cydia-源&quot;&gt;&lt;a href=&quot;#Cydia-源&quot; class=&quot;headerlink&quot; title=&quot;Cydia 源&quot;&gt;&lt;/a&gt;Cydia 源&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;JBnow Repo &lt;a href=&quot;http://repo.jbnow.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://repo.jbnow.me/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;BigBoss Repo &lt;a href=&quot;http://apt.thebigboss.org/repofiles/cydia/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://apt.thebigboss.org/repofiles/cydia/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ModMyi Repo &lt;a href=&quot;http://apt.modmyi.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://apt.modmyi.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;BiteYourApple Repo &lt;a href=&quot;http://repo.biteyourapple.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://repo.biteyourapple.net/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;filippoBiga &lt;a href=&quot;http://filippobiga.me/repo/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://filippobiga.me/repo/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SINful iPhone Rep &lt;a href=&quot;http://sinfuliphonerepo.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://sinfuliphonerepo.com/&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;ihacksrepo &lt;a href=&quot;http://ihacksrepo.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ihacksrepo.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;iNsanelyi Repo &lt;a href=&quot;http://repo.insanelyi.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://repo.insanelyi.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;iHackStore Repo &lt;a href=&quot;http://ihackstore.com/repo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ihackstore.com/repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SinfuliPhone Repo &lt;a href=&quot;http://sinfuliphonerepo.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://sinfuliphonerepo.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;iPhoneCake Repo &lt;a href=&quot;http://cydia.iphonecake.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cydia.iphonecake.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;威锋源 &lt;a href=&quot;http://apt.so/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://apt.so/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PP助手源 &lt;a href=&quot;http://apt.25pp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://apt.25pp.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;IAPCrazy &lt;a href=&quot;http://apt.youyuanapp.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://apt.youyuanapp.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;小白源 &lt;a href=&quot;http://apt.xbyy.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://apt.xbyy.cn&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosky.tech/categories/iOS/"/>
    
    
      <category term="Jailbreak" scheme="http://chaosky.tech/tags/Jailbreak/"/>
    
      <category term="Cydia" scheme="http://chaosky.tech/tags/Cydia/"/>
    
  </entry>
  
  <entry>
    <title>非官方iOS9.2-iOS9.3.3越狱图文教程</title>
    <link href="http://chaosky.tech/2016/12/07/Jailbreak-Using-Pangu-and-Cydia-Impactor/"/>
    <id>http://chaosky.tech/2016/12/07/Jailbreak-Using-Pangu-and-Cydia-Impactor/</id>
    <published>2016-12-07T01:06:21.000Z</published>
    <updated>2020-03-16T07:31:28.338Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本越狱教程在 Windows 和 Mac 上都可以。</p><h2 id="越狱前须知"><a href="#越狱前须知" class="headerlink" title="越狱前须知"></a>越狱前须知</h2><ol><li>备份，备份，备份</li><li>支持设备: iPhone 5s iPhone 6 iPhone 6+ iPhone 6s iPhone 6s+ iPhone 5E iPod Touch 6G iPad Mini 2 iPad Mini 3 iPad Mini 4 iPad Air iPad Air 2 iPad Pro</li><li>支持固件版本：iOS9.2 ~ iOS9.3.3</li><li>电脑或者 Mac 安装iTunes，保证设备电量充足</li></ol><a id="more"></a><h2 id="越狱步骤"><a href="#越狱步骤" class="headerlink" title="越狱步骤"></a>越狱步骤</h2><h3 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h3><p>下载最新版的盘古越狱 IPA 文件。下载地址：<a href="http://www.iclarified.com/files/pangu/NvwaStone_1.0.ipa" target="_blank" rel="noopener">http://www.iclarified.com/files/pangu/NvwaStone_1.0.ipa</a></p><p>下载 Cydia Impactor。下载地址：<a href="http://www.cydiaimpactor.com" target="_blank" rel="noopener">http://www.cydiaimpactor.com</a></p><p>Mac</p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268035-640.jpg" alt="268035-640"></p><p>Windows</p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268173.jpg" alt="268173"></p><h3 id="安装-Impactor"><a href="#安装-Impactor" class="headerlink" title="安装 Impactor"></a>安装 Impactor</h3><p>Mac：双击 Impactor dmg 安装</p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268041.jpg" alt="268041"></p><p>Windows: 解压缩 Impactor zip</p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268176.jpg" alt="268176"></p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268178.jpg" alt="268178"></p><h3 id="运行-Impactor-并-连接-iPhone"><a href="#运行-Impactor-并-连接-iPhone" class="headerlink" title="运行 Impactor 并 连接 iPhone"></a>运行 Impactor 并 连接 iPhone</h3><p><img src="http://file.blog.chaosky.tech/2016-12-07-268050.jpg" alt="268050"></p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268053.jpg" alt="268053"></p><h3 id="安装-NvwaStone-IPA"><a href="#安装-NvwaStone-IPA" class="headerlink" title="安装 NvwaStone IPA"></a>安装 NvwaStone IPA</h3><p>拖拽 NvwaStone IPA 文件到 Cydia Impactor 应用中。</p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268070.jpg" alt="268070"></p><p>拖拽进去以后，将会要求你输入 Apple ID 和 密码，用来对 IPA 文件签名并且能够运行在你的设备上。不幸的是，如果你没有开发者账号，IPA 文件签名只有7天有效，也就是只能运行7天。如果你有开发者账号 IPA 文件签名有1年。</p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268059.jpg" alt="268059"></p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268062.jpg" alt="268062"></p><p>Cydia Impactor 将会显示一个警告给开发者：这个应用将会撤销和替换该账号已有的开发证书，这可能会影响你现在的开发工作。<br><img src="http://file.blog.chaosky.tech/2016-12-07-268065.jpg" alt="268065"></p><p>Cydia Impactor 将会签名 IPA 并 安装盘古越狱 APP 到你的设备上。</p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268073.jpg" alt="268073"></p><h3 id="信任开发者描述文件"><a href="#信任开发者描述文件" class="headerlink" title="信任开发者描述文件"></a>信任开发者描述文件</h3><p>盘古越狱 APP 安装到设备上后，你需要信任开发者描述文件。</p><p>点击【设置】——&gt; 【通用】——&gt; 【描述文件与设备管理】，找到你在 Cydia Impactor 中填写的对应邮箱地址。PS: 开发者账号不用信任即可。</p><p><img src="http://file.blog.chaosky.tech/2016-12-07-QQ20161207-0@2x.png" alt="QQ20161207-0@2x"></p><p><img src="http://file.blog.chaosky.tech/2016-12-07-QQ20161207-1@2x.png" alt="QQ20161207-1@2x"></p><p><img src="http://file.blog.chaosky.tech/2016-12-07-QQ20161207-2@2x.png" alt="QQ20161207-2@2x"></p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268088.jpg" alt="268088"></p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268091.jpg" alt="268091"></p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268094.jpg" alt="268094"></p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268097.jpg" alt="268097"></p><h3 id="运行-盘古越狱-APP"><a href="#运行-盘古越狱-APP" class="headerlink" title="运行 盘古越狱 APP"></a>运行 盘古越狱 APP</h3><p>回到主界面，运行 盘古越狱 APP。</p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268100.jpg" alt="268100"></p><p>允许通知</p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268103.jpg" alt="268103"></p><p>点击开始按钮</p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268106.jpg" alt="268106"></p><p>锁屏等待6秒钟，你将会收到你的设备已经越狱成功的通知。</p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268112.jpg" alt="268112"></p><p>解锁设备，重新进入盘古越狱APP，正在准备越狱环境和安装 Cydia。</p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268115.jpg" alt="268115"></p><p>完成后，屏幕会重启，Cydia出现在主界面上。</p><p><img src="http://file.blog.chaosky.tech/2016-12-07-268118.jpg" alt="268118"></p><h3 id="重要提示"><a href="#重要提示" class="headerlink" title="重要提示"></a>重要提示</h3><p>每次重启设备后，需要重新运行盘古越狱 APP 来恢复越狱环境。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://onlinejailbreak.com/osx" target="_blank" rel="noopener">http://onlinejailbreak.com/osx</a></li><li><a href="http://onlinejailbreak.com/windows" target="_blank" rel="noopener">http://onlinejailbreak.com/windows</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本越狱教程在 Windows 和 Mac 上都可以。&lt;/p&gt;
&lt;h2 id=&quot;越狱前须知&quot;&gt;&lt;a href=&quot;#越狱前须知&quot; class=&quot;headerlink&quot; title=&quot;越狱前须知&quot;&gt;&lt;/a&gt;越狱前须知&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;备份，备份，备份&lt;/li&gt;
&lt;li&gt;支持设备: iPhone 5s iPhone 6 iPhone 6+ iPhone 6s iPhone 6s+ iPhone 5E iPod Touch 6G iPad Mini 2 iPad Mini 3 iPad Mini 4 iPad Air iPad Air 2 iPad Pro&lt;/li&gt;
&lt;li&gt;支持固件版本：iOS9.2 ~ iOS9.3.3&lt;/li&gt;
&lt;li&gt;电脑或者 Mac 安装iTunes，保证设备电量充足&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosky.tech/categories/iOS/"/>
    
    
      <category term="Jailbreak" scheme="http://chaosky.tech/tags/Jailbreak/"/>
    
      <category term="Cydia" scheme="http://chaosky.tech/tags/Cydia/"/>
    
  </entry>
  
  <entry>
    <title>iOS 依赖库管理工具</title>
    <link href="http://chaosky.tech/2016/11/13/Cocoa-Dependency-Manager/"/>
    <id>http://chaosky.tech/2016/11/13/Cocoa-Dependency-Manager/</id>
    <published>2016-11-13T12:31:44.000Z</published>
    <updated>2020-03-16T07:31:28.337Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h2><h3 id="CocoaPods-简介"><a href="#CocoaPods-简介" class="headerlink" title="CocoaPods 简介"></a>CocoaPods 简介</h3><p>CocoaPods是一个用来帮助我们管理第三方依赖库的工具。它可以解决库与库之间的依赖关系，下载库的源代码，同时通过创建一个Xcode的workspace来将这些第三方库和我们的工程连接起来，供我们开发使用。</p><p>使用CocoaPods的目的是让我们能自动化的、集中的、直观的管理第三方开源库。</p><a id="more"></a><h3 id="检查Mac是否安装Ruby和gem"><a href="#检查Mac是否安装Ruby和gem" class="headerlink" title="检查Mac是否安装Ruby和gem"></a>检查Mac是否安装Ruby和gem</h3><p>在终端中输入命令：<code>ruby --version</code> 和<code>gem --version</code></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ruby --version</span><br><span class="line">ruby <span class="number">2.0</span><span class="number">.0</span>p643 (<span class="number">2015</span><span class="number">-02</span><span class="number">-25</span> revision <span class="number">49749</span>) [x86_64-darwin14<span class="number">.3</span><span class="number">.0</span>]</span><br><span class="line">$ gem --version</span><br><span class="line"><span class="number">2.4</span><span class="number">.8</span></span><br></pre></td></tr></table></figure><p>Ruby 是一门开发语言，gem 为 Ruby 第三方库管理工具，CocoaPods 是用 Ruby 写的一个第三方工具。</p><p><strong>Ruby的版本需要大于 2.2.2版本。如果小于该版本，通过以下方式安装更高版本的 Ruby。</strong></p><h3 id="安装-Ruby-环境"><a href="#安装-Ruby-环境" class="headerlink" title="安装 Ruby 环境"></a>安装 Ruby 环境</h3><ol><li><p>安装 Xcode 及 Command Line Tools。安装 Command Line Tools 命令：<code>xcode-select --install</code></p></li><li><p>安装 RVM，Ruby 的多版本管理工具。并通过 RVM 安装更高版本的 Ruby。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> curl -L https:<span class="comment">//get.rvm.io | bash -s stable</span></span><br><span class="line"><span class="symbol">$</span> source ~/.rvm/scripts/rvm</span><br><span class="line"><span class="symbol">$</span> rvm install <span class="number">2.3</span><span class="number">.0</span></span><br><span class="line"><span class="symbol">$</span> rvm use <span class="number">2.3</span><span class="number">.0</span></span><br><span class="line"><span class="symbol">$</span> /bin/bash --login</span><br></pre></td></tr></table></figure></li><li><p>修改 gem 镜像</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --<span class="built_in">add</span> http<span class="variable">s:</span>//gems.<span class="keyword">ruby</span>-china.org/ --<span class="built_in">remove</span> http<span class="variable">s:</span>//rubygems.org/</span><br><span class="line">$ gem sources -<span class="keyword">l</span></span><br><span class="line">http<span class="variable">s:</span>//gems.<span class="keyword">ruby</span>-china.org</span><br><span class="line"># 确保只有 gems.<span class="keyword">ruby</span>-china.org</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装-CocoaPods"><a href="#安装-CocoaPods" class="headerlink" title="安装 CocoaPods"></a>安装 CocoaPods</h3><p>安装</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem <span class="keyword">install</span> cocoapods</span><br></pre></td></tr></table></figure><p>初始化 CocoaPods 环境</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod <span class="built_in">setup</span></span><br></pre></td></tr></table></figure><p>初始化环境需要更新下载 CocoaPods 仓库，该步骤花费很长时间。更简便的方式是：从其他已初始化好的电脑上，拷贝目录 <code>~/.cocoapods/repos/</code> 到本机的相同目录中。</p><h3 id="使用-CocoaPods"><a href="#使用-CocoaPods" class="headerlink" title="使用 CocoaPods"></a>使用 CocoaPods</h3><ol><li><p>创建 Xcode 工程并切换到该工程路径</p></li><li><p>使用命令 <code>pod init</code> 在当前文件夹下生成一个 <strong>Podfile</strong> 文件</p></li><li><p>编辑 Podfile，输入如下类似信息：</p> <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>vim Podfile</span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'8.0'</span></span><br><span class="line"><span class="comment"># 屏蔽 CocoaPods 库里面的所有警告</span></span><br><span class="line">inhibit_all_warnings!</span><br><span class="line"></span><br><span class="line">target <span class="string">'CocoaPodsDemo'</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># 可以用framework的pod替代静态库</span></span><br><span class="line">  <span class="comment"># use_frameworks!</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Pods for CocoaPodsDemo</span></span><br><span class="line">  pod <span class="string">"AFNetworking"</span>, <span class="string">"~&gt; 2.5.4"</span></span><br><span class="line">  pod <span class="string">'SDWebImage'</span></span><br><span class="line">  pod <span class="string">'KVNProgress'</span></span><br><span class="line"></span><br><span class="line">  target <span class="string">'CocoaPodsDemoTests'</span> <span class="keyword">do</span></span><br><span class="line">    inherit! <span class="symbol">:search_paths</span></span><br><span class="line">    <span class="comment"># Pods for testing</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  target <span class="string">'CocoaPodsDemoUITests'</span> <span class="keyword">do</span></span><br><span class="line">    inherit! <span class="symbol">:search_paths</span></span><br><span class="line">    <span class="comment"># Pods for testing</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Pod 语法格式为：<code>pod &#39;第三库名称&#39;, &#39;版本号&#39;</code>，一个依赖项通过pod名和可选的版本号来声明。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pod</span> <span class="string">'AFNetworking'</span>, <span class="string">'~&gt; 2.5.4'</span></span><br></pre></td></tr></table></figure><p>最新版本的依赖，可以忽略版本号，这样写：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pod</span> <span class="string">'AFNetworking'</span></span><br></pre></td></tr></table></figure><p>指定Pod固定版本，可以写上具体的版本号来指定：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pod</span> <span class="string">'AFNetworking'</span>, <span class="string">'2.5.4'</span></span><br></pre></td></tr></table></figure><p>版本号标识区别：</p><blockquote><p><strong>&gt;1.0</strong>        高于1.0的任何版本<br><strong>&gt;= 1.0</strong>    至少版本为1.0<br><strong>&lt;1.0</strong>        低于1.0的任何版本<br><strong>&lt;=1.0</strong>        版本1.0和任何低于1.0的版本<br><strong>~&gt; 1.0</strong>     兼容1.0版本的最新版<br><strong>== 1.0或1.0</strong>    都表示指定版本</p></blockquote><p><strong>inhibit_all_warnings!</strong>：屏蔽 CocoaPods 库里面的所有警告<br><strong>use_frameworks!</strong>：可以用framework的pod替代静态库</p></li><li><p>安装工程依赖的第三方库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ pod <span class="keyword">install</span></span><br><span class="line">Updating <span class="keyword">local</span> specs repositories</span><br><span class="line">Analyzing dependencies</span><br><span class="line">Downloading dependencies</span><br><span class="line">Installing AFNetworking (<span class="number">2.5</span><span class="number">.4</span>)</span><br><span class="line">Installing KVNProgress (<span class="number">2.2</span><span class="number">.2</span>)</span><br><span class="line">Installing SDWebImage (<span class="number">3.7</span><span class="number">.3</span>)</span><br><span class="line">Generating Pods <span class="keyword">project</span></span><br><span class="line">Integrating <span class="keyword">client</span> <span class="keyword">project</span></span><br><span class="line">[!] Please <span class="keyword">close</span> <span class="keyword">any</span> <span class="keyword">current</span> Xcode sessions <span class="keyword">and</span> <span class="keyword">use</span> <span class="string">`CocoaPodsDemo.xcworkspace`</span> <span class="keyword">for</span> this <span class="keyword">project</span> <span class="keyword">from</span> <span class="keyword">now</span> on.</span><br><span class="line">Sending stats</span><br><span class="line">Pod installation <span class="keyword">complete</span>! There <span class="keyword">are</span> <span class="number">3</span> dependencies <span class="keyword">from</span> the Podfile <span class="keyword">and</span> <span class="number">3</span> total</span><br><span class="line">pods installed.</span><br></pre></td></tr></table></figure><p>若出现<code>pods installed</code>字样表示安装成功。</p></li><li><p>关闭Xcode工程，打开.xcworkspace文件。</p></li><li><p>在工程中导入第三库文件，只需要<code>#import &lt;AFNetworking.h&gt;</code>类似的即可，开启CocoaPods之旅。</p></li></ol><p>更多用法参考本文提供的参考链接。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a href="http://code4app.com/article/cocoapods-install-usage" target="_blank" rel="noopener">http://code4app.com/article/cocoapods-install-usage</a></li><li><a href="http://blog.csdn.net/wzzvictory/article/details/18737437" target="_blank" rel="noopener">http://blog.csdn.net/wzzvictory/article/details/18737437</a></li><li><a href="http://blog.csdn.net/wzzvictory/article/details/19178709" target="_blank" rel="noopener">http://blog.csdn.net/wzzvictory/article/details/19178709</a></li></ol><h2 id="Carthage"><a href="#Carthage" class="headerlink" title="Carthage"></a>Carthage</h2><h3 id="Carthage-简介"><a href="#Carthage-简介" class="headerlink" title="Carthage 简介"></a>Carthage 简介</h3><p>Carthage的目标是用最简单的方式来管理Cocoa第三方框架。</p><p>Carthage编译你的依赖，并提供框架的二进制文件，但你仍然保留对项目的结构和设置的完整控制。Carthage不会自动的修改你的项目文件或编译设置。</p><p><strong>Carthage只正式支持动态框架，动态框架能够在任何版本的OS X上使用，但只能在iOS 8及以上版本使用。</strong></p><h3 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h3><p>OS X 不可或缺的套件管理器，用于安装命令工具。</p><p>终端中执行如下命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/ruby -e "$(curl -fsSL https:/</span><span class="regexp">/raw.githubusercontent.com/</span>Homebrew<span class="regexp">/install/m</span>aster<span class="regexp">/install)"</span></span><br></pre></td></tr></table></figure><h3 id="安装-Carthage"><a href="#安装-Carthage" class="headerlink" title="安装 Carthage"></a>安装 Carthage</h3><p>终端执行命令安装Carthage</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>update</span><br><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>carthage</span><br></pre></td></tr></table></figure><h3 id="使用Carthage"><a href="#使用Carthage" class="headerlink" title="使用Carthage"></a>使用Carthage</h3><ol><li><p>创建Xcode工程并切换到该工程路径</p></li><li><p>创建一个<code>Cartfile</code>，将你想要使用的框架列在里面</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">github <span class="string">"AFNetworking/AFNetworking"</span><span class="function"> ~&gt;</span> <span class="number">3.0</span></span><br><span class="line">github <span class="string">"rs/SDWebImage"</span></span><br></pre></td></tr></table></figure></li><li><p>运行<code>carthage update</code>，将获取依赖文件到一个<code>Carthage.checkout</code>文件夹，然后编译每个依赖</p></li><li><p>在你的应用程序target的<code>General</code>设置标签中的<code>Embedded Binaries</code>区域，将框架从<code>Carthage.build</code>文件夹拖拽进去。</p></li></ol><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a href="http://www.cocoachina.com/ios/20141204/10528.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20141204/10528.html</a></li><li><a href="https://github.com/Carthage/Carthage" target="_blank" rel="noopener">官方文档</a></li></ol><h2 id="Carthage与CocoaPods的不同"><a href="#Carthage与CocoaPods的不同" class="headerlink" title="Carthage与CocoaPods的不同"></a>Carthage与CocoaPods的不同</h2><ol><li><p>Carthage只支持iOS 8及以上版本使用。</p></li><li><p>首先，CocoaPods默认会自动创建并更新你的应用程序和所有依赖的Xcode workspace。Carthage使用xcodebuild来编译框架的二进制文件，但如何集成它们将交由用户自己判断。CocoaPods的方法更易于使用，但Carthage更灵活并且是非侵入性的。</p></li><li><p>CocoaPods的目标在它的README文件描述如下：</p><blockquote><p>…为提高第三方开源库的可见性和参与度，创建一个更中心化的生态系统。</p></blockquote><p>与之对照，Carthage创建的是去中心化的依赖管理器。它没有总项目的列表，这能够减少维护工作并且避免任何中心化带来的问题（如中央服务器宕机）。不过，这样也有一些缺点，就是项目的发现将更困难，用户将依赖于Github的趋势页面或者类似的代码库来寻找项目。</p></li><li><p>CocoaPods项目同时还必须包含一个podspec文件，里面是项目的一些元数据，以及确定项目的编译方式。Carthage使用xcodebuild来编译依赖，而不是将他们集成进一个workspace，因此无需类似的设定文件。不过依赖需要包含自己的Xcode工程文件来描述如何编译。</p></li><li><p>最后，我们创建Carthage的原因是想要一种尽可能简单的工具——一个只关心本职工作的依赖管理器，而不是取代部分Xcode的功能，或者需要让框架作者做一些额外的工作。CocoaPods提供的一些特性很棒，但由于附加的复杂性，它们将不会被包含在Carthage当中。</p></li></ol><h2 id="Swift-Package-Manager"><a href="#Swift-Package-Manager" class="headerlink" title="Swift Package Manager"></a>Swift Package Manager</h2><p>Swift包管理器是一个用于管理Swift代码分发的工具。它与Swift构建系统集成，自动化处理下载、编译和链接依赖关系。</p><p>软件包管理器包含在Swift 3.0及更高版本中。</p><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><h4 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h4><p>下载安装 <a href="https://developer.apple.com/download/" target="_blank" rel="noopener">Xcode 8.1</a>。</p><h4 id="Ubuntu-Linux"><a href="#Ubuntu-Linux" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h4><ol><li><p>安装以下Linux 系统包：</p> <figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">$ sudo apt-<span class="built_in">get</span> install clang libicu-<span class="built_in">dev</span> libcurl4-openssl-<span class="built_in">dev</span> libssl-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure></li><li><p>从 <a href="https://swift.org/download/" target="_blank" rel="noopener">swift.org</a> 下载 Swift 工具链。</p></li><li><p>解压缩 <strong>.tar.gz</strong> 文件，更新 <strong>PATH</strong> 环境变量，包含以下工具：</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="builtin-name">export</span> <span class="attribute">PATH</span>=&lt;path <span class="keyword">to</span> uncompressed tar contents&gt;/usr/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><ol><li><p>创建工程路径</p> <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> myFirstProject</span><br></pre></td></tr></table></figure></li><li><p>使用 Swift 包管理器创建 Swift 工程</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> myFirstProject</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> swift package init --<span class="built_in">type</span> executable</span></span><br></pre></td></tr></table></figure></li><li><p>在 <strong>myFirstProject</strong> 目录下的目录结构如下</p> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">myFirstProject</span></span><br><span class="line">├── Package.<span class="keyword">swift</span></span><br><span class="line"><span class="keyword">├── </span>Sources</span><br><span class="line">│   └── main.<span class="keyword">swift</span></span><br><span class="line"><span class="keyword">└── </span>Tests</span><br></pre></td></tr></table></figure></li><li><p>在 <strong>Package.swift</strong> 中添加依赖项</p> <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PackageDescription</span><br><span class="line"></span><br><span class="line">let <span class="keyword">package</span> = <span class="keyword">Package</span>(</span><br><span class="line">    name: <span class="string">"myFirstProject"</span>,</span><br><span class="line">    <span class="keyword">dependencies</span>: [</span><br><span class="line">        .<span class="keyword">Package</span>(url: <span class="string">"https://github.com/IBM-Swift/Kitura.git"</span>, majorVersion: <span class="number">1</span>, minor: <span class="number">1</span>)</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure></li><li><p>编译程序</p> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">swift </span><span class="keyword">build</span></span><br></pre></td></tr></table></figure></li><li><p>在代码中就可以通过 <code>import Kitura</code> 导入模块。<br> 在 <strong>Sources/main.swift</strong> 添加如下代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  import Kitura</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new router</span></span><br><span class="line"><span class="keyword">let</span> router = <span class="constructor">Router()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle HTTP GET requests to /</span></span><br><span class="line">router.get(<span class="string">"/"</span>) &#123;</span><br><span class="line">    request, response, next <span class="keyword">in</span></span><br><span class="line">    response.send(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    next<span class="literal">()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add an HTTP server and connect it to the router</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Kitura</span>.</span></span>add<span class="constructor">HTTPServer(<span class="params">onPort</span>: 8090, <span class="params">with</span>: <span class="params">router</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the Kitura runloop (this call never returns)</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Kitura</span>.</span></span>run<span class="literal">()</span></span><br></pre></td></tr></table></figure></li><li><p>运行</p> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .build<span class="regexp">/debug/my</span>FirstProject</span><br></pre></td></tr></table></figure></li><li><p>在 macOS 上可以生成 Xcode 工程</p> <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ swift <span class="keyword">package</span> <span class="keyword">generate</span>-xcodeproj</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CocoaPods&quot;&gt;&lt;a href=&quot;#CocoaPods&quot; class=&quot;headerlink&quot; title=&quot;CocoaPods&quot;&gt;&lt;/a&gt;CocoaPods&lt;/h2&gt;&lt;h3 id=&quot;CocoaPods-简介&quot;&gt;&lt;a href=&quot;#CocoaPods-简介&quot; class=&quot;headerlink&quot; title=&quot;CocoaPods 简介&quot;&gt;&lt;/a&gt;CocoaPods 简介&lt;/h3&gt;&lt;p&gt;CocoaPods是一个用来帮助我们管理第三方依赖库的工具。它可以解决库与库之间的依赖关系，下载库的源代码，同时通过创建一个Xcode的workspace来将这些第三方库和我们的工程连接起来，供我们开发使用。&lt;/p&gt;
&lt;p&gt;使用CocoaPods的目的是让我们能自动化的、集中的、直观的管理第三方开源库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosky.tech/categories/iOS/"/>
    
    
      <category term="CocoaPods" scheme="http://chaosky.tech/tags/CocoaPods/"/>
    
      <category term="Carthage" scheme="http://chaosky.tech/tags/Carthage/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0 要点</title>
    <link href="http://chaosky.tech/2016/11/11/Effective-Objective-C-2-0/"/>
    <id>http://chaosky.tech/2016/11/11/Effective-Objective-C-2-0/</id>
    <published>2016-11-11T09:06:06.000Z</published>
    <updated>2020-03-16T07:31:28.335Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第1章-熟悉-Objective-C"><a href="#第1章-熟悉-Objective-C" class="headerlink" title="第1章 熟悉 Objective-C"></a>第1章 熟悉 Objective-C</h2><h3 id="第1条-了解-Objective-C-语言的起源"><a href="#第1条-了解-Objective-C-语言的起源" class="headerlink" title="第1条 了解 Objective-C 语言的起源"></a>第1条 了解 Objective-C 语言的起源</h3><ul><li>Objective-C 为C语言添加了面向对象特性，是其超集。Objective-C 使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定。</li><li>理解C语言的核心概念有助于写好Objective-C程序。尤其要掌握内存模型与指针。</li></ul><h3 id="第2条-在类的头文件中尽量少引入其他头文件"><a href="#第2条-在类的头文件中尽量少引入其他头文件" class="headerlink" title="第2条 在类的头文件中尽量少引入其他头文件"></a>第2条 在类的头文件中尽量少引入其他头文件</h3><ul><li>除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合。</li><li>有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把『该类遵循某协议』的这条声明移至『class-continuation分类』中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。</li></ul><h3 id="第3条-多用字面量语法，少用与之等价的方法"><a href="#第3条-多用字面量语法，少用与之等价的方法" class="headerlink" title="第3条 多用字面量语法，少用与之等价的方法"></a>第3条 多用字面量语法，少用与之等价的方法</h3><ul><li>应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。</li><li>应该通过取下标操作来访问数组下标或字典中的键所对应的元素。</li><li>用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。</li></ul><h3 id="第4条-多用类型常量，少用-define-预处理指令"><a href="#第4条-多用类型常量，少用-define-预处理指令" class="headerlink" title="第4条 多用类型常量，少用 #define 预处理指令"></a>第4条 多用类型常量，少用 #define 预处理指令</h3><ul><li>不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。</li><li>在实现文件中使用 static const 来定义『只在编译单元内可见的常量』（translation-unit-specific constant）。由于此类常量不在全局符号表中，所以无须为其名称加前缀。</li><li>在头文件中使用 extern 来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所有其名称应加以区隔，通常用与之相关的类名做前缀。</li></ul><h3 id="第5条-用枚举表示状态、选项、状态码"><a href="#第5条-用枚举表示状态、选项、状态码" class="headerlink" title="第5条 用枚举表示状态、选项、状态码"></a>第5条 用枚举表示状态、选项、状态码</h3><ul><li>应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。</li><li>如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。</li><li>用 NS_ENUM 与 NS_OPTIONS 宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。</li><li>在处理枚举类型的 switch 语句中不要实现 default 分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch 语句并未处理所有枚举。</li></ul><a id="more"></a><h2 id="第2章-对象、消息、运行期"><a href="#第2章-对象、消息、运行期" class="headerlink" title="第2章 对象、消息、运行期"></a>第2章 对象、消息、运行期</h2><h3 id="第6条-理解『属性』这一概念"><a href="#第6条-理解『属性』这一概念" class="headerlink" title="第6条 理解『属性』这一概念"></a>第6条 理解『属性』这一概念</h3><ul><li>可以用 @property 语法来定义对象中所封装的数据。</li><li>通过『特质』来指定存储数据所需的正确语义。</li><li>在设置所对应的实例变量时，一定要遵从该属性所声明的语义。</li><li>开发 iOS 程序时应该使用 nonatomic 属性，因为 atomic 属性会严重影响性能。</li></ul><h3 id="第7条-在对象内部尽量直接访问实例变量"><a href="#第7条-在对象内部尽量直接访问实例变量" class="headerlink" title="第7条 在对象内部尽量直接访问实例变量"></a>第7条 在对象内部尽量直接访问实例变量</h3><ul><li>在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应通过属性来写。</li><li>在初始化方法及dealloc方法中，总是应该直接通过实例变量来读写数据。</li><li>有时会使用惰性初始化技术配置某份数据，这种情况下，需要通过属性来读取数据。</li></ul><h3 id="第8条-理解『对象等同性』这一概念"><a href="#第8条-理解『对象等同性』这一概念" class="headerlink" title="第8条 理解『对象等同性』这一概念"></a>第8条 理解『对象等同性』这一概念</h3><ul><li>若想检测对象的等同性，请提供『isEqual:』与 hash 方法。</li><li>相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。</li><li>不要盲目地逐个检测每条属性，而是应该依照具体需求来指定检测方案。</li><li>编写 hash 方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。</li></ul><h3 id="第9条-以『类族模式』隐藏实现细节"><a href="#第9条-以『类族模式』隐藏实现细节" class="headerlink" title="第9条 以『类族模式』隐藏实现细节"></a>第9条 以『类族模式』隐藏实现细节</h3><ul><li>类族模式可以把实现细节隐藏在一套简单的公共接口后面。</li><li>系统框架中经常使用类族。</li><li>从类族的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读。</li></ul><h3 id="第10条-在既有类中使用关联对象存放自定义数据"><a href="#第10条-在既有类中使用关联对象存放自定义数据" class="headerlink" title="第10条 在既有类中使用关联对象存放自定义数据"></a>第10条 在既有类中使用关联对象存放自定义数据</h3><ul><li>可以通过『关联对象』机制来把两个对象连起来。</li><li>定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的『拥有关系』与『非拥有关系』。</li><li>只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的 bug。</li></ul><h3 id="第11条-理解-objc-msgSend-的作用"><a href="#第11条-理解-objc-msgSend-的作用" class="headerlink" title="第11条 理解 objc_msgSend 的作用"></a>第11条 理解 objc_msgSend 的作用</h3><ul><li>消息由接收者、选择子及参数构成。给某对象『发送消息』（invoke a message）也就相当于在该对象上『调用方法』（call a method）。</li><li>发给某对象的全部消息都要由『动态消息派发系统』（dynamic message dispatch system）来处理，该系统会查出对应的方法，并执行其代码。</li></ul><h3 id="第12条-理解消息转发机制"><a href="#第12条-理解消息转发机制" class="headerlink" title="第12条 理解消息转发机制"></a>第12条 理解消息转发机制</h3><ul><li>若对象无法响应某个选择子，则进入消息转发流程。</li><li>通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。</li><li>对象可以把其无法解读的某些选择子交给其他对象来处理。</li><li>经过上述两步之后，如果还是没办法处理选择子，那就启动完整的消息转发机制。<br><img src="http://file.blog.chaosky.tech/2016-12-28-20160629125258569.png" alt="20160629125258569"></li></ul><h3 id="第13条-用『方法调配技术』调试『黑盒方法』"><a href="#第13条-用『方法调配技术』调试『黑盒方法』" class="headerlink" title="第13条 用『方法调配技术』调试『黑盒方法』"></a>第13条 用『方法调配技术』调试『黑盒方法』</h3><ul><li>使用另一份实现来替换原来的方法实现，这道工序叫做『方法调配』，开发者常用此技术向原有实现中添加新功能。</li><li>一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。</li></ul><h3 id="第14条-理解『类对象』的用意"><a href="#第14条-理解『类对象』的用意" class="headerlink" title="第14条 理解『类对象』的用意"></a>第14条 理解『类对象』的用意</h3><ul><li>每个实例都有一个指向 Class 对象的指针，用以表明其类型，而这些 Class 对象则构成了类的继承体系。</li><li>如果对象类型无法在编译器确定，那么久应该使用类型信息查询方法来探知。</li><li>尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。</li></ul><h2 id="第3章-接口与-API-设计"><a href="#第3章-接口与-API-设计" class="headerlink" title="第3章 接口与 API 设计"></a>第3章 接口与 API 设计</h2><h3 id="第15条-用前缀避免命名空间冲突"><a href="#第15条-用前缀避免命名空间冲突" class="headerlink" title="第15条 用前缀避免命名空间冲突"></a>第15条 用前缀避免命名空间冲突</h3><ul><li>选择与你的公司、应用程序或二者皆有关联之名称作为类名的前缀，并在所有代码中均使用这一前缀。</li><li>若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀。</li></ul><h3 id="第16条-提供『全能初始化方法』"><a href="#第16条-提供『全能初始化方法』" class="headerlink" title="第16条 提供『全能初始化方法』"></a>第16条 提供『全能初始化方法』</h3><ul><li>在类中提供一个全能初始化方法，并在文档里指明。其他初始化方法均应调用此方法。</li><li>若全能初始化方法与超类不同，则需覆写超类中的对应方法。</li><li>如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。</li></ul><h3 id="第17条-实现-description-方法"><a href="#第17条-实现-description-方法" class="headerlink" title="第17条 实现 description 方法"></a>第17条 实现 description 方法</h3><ul><li>实现 description 方法返回一个有意义的字符串，用以描述该实例。</li><li>若想在调试时打印出更详尽的对象描述信息，则应实现 debugDescription 方法。</li></ul><h3 id="第18条-尽量使用不可变对象"><a href="#第18条-尽量使用不可变对象" class="headerlink" title="第18条 尽量使用不可变对象"></a>第18条 尽量使用不可变对象</h3><ul><li>尽量创建不可变的对象。</li><li>若某属性仅可于对象内部修改，则在『class-continuation 分类』中将其由 readonly 属性扩展为 readwrite 属性。</li><li>不要把可变的 collection 作为属性公开，而应提供相关方法，以此修改对象中的可变 collection。</li></ul><h3 id="第19条-使用清晰而协调的命名方式"><a href="#第19条-使用清晰而协调的命名方式" class="headerlink" title="第19条 使用清晰而协调的命名方式"></a>第19条 使用清晰而协调的命名方式</h3><ul><li>起名时应遵从标准的 Objective-C 命名规范，这样创建出来的接口更容易为开发者所理解。</li><li>方法名要言简意赅，从左至右读起来要像个日常用语中的句子才好。</li><li>方法名里不要使用缩略后的类型名称。</li><li>给方法起名时的第一要务就是确保其风格与你自己的代码或所要集成的框架相符。</li></ul><h3 id="第20条-为私有方法名加前缀"><a href="#第20条-为私有方法名加前缀" class="headerlink" title="第20条 为私有方法名加前缀"></a>第20条 为私有方法名加前缀</h3><ul><li>给私有方法的名称加上前缀，这样可以很容易地将其同公共方法区分开。</li><li>不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司用的。</li></ul><h3 id="第21条-理解-Objective-C-错误模型"><a href="#第21条-理解-Objective-C-错误模型" class="headerlink" title="第21条 理解 Objective-C 错误模型"></a>第21条 理解 Objective-C 错误模型</h3><ul><li>只要发生了可使整个应用程序崩溃的严重错误时，才应使用异常。</li><li>在错误不那么严重的情况下，可以指派『委托方法』（delegate method）来处理错误，也可以把错误信息放在 NSError 对象里，经由『输出参数』返回给调用者。</li></ul><h3 id="第22条-理解-NSCopying-协议"><a href="#第22条-理解-NSCopying-协议" class="headerlink" title="第22条 理解 NSCopying 协议"></a>第22条 理解 NSCopying 协议</h3><ul><li>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。</li><li>如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。</li><li>复制对象时需决定采用浅拷贝还是深拷贝，一般情况下应该尽量执行浅拷贝。</li><li>如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。</li></ul><h2 id="第4章-协议与分类"><a href="#第4章-协议与分类" class="headerlink" title="第4章 协议与分类"></a>第4章 协议与分类</h2><h3 id="第23条-通过委托与数据源协议进行对象间通信"><a href="#第23条-通过委托与数据源协议进行对象间通信" class="headerlink" title="第23条 通过委托与数据源协议进行对象间通信"></a>第23条 通过委托与数据源协议进行对象间通信</h3><ul><li>委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象。</li><li>将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法。</li><li>当某对象需要从另一个对象中获取数据时，可以使用委托模式。这种情况下，该模式亦称『数据源协议』（data source protocal）。</li><li>若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。</li></ul><h3 id="第24条-将类的实现代码分散到便于管理的数个分类之中"><a href="#第24条-将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="第24条 将类的实现代码分散到便于管理的数个分类之中"></a>第24条 将类的实现代码分散到便于管理的数个分类之中</h3><ul><li>使用分类机制把类的实现代码划分成易于管理的小块。</li><li>将应该视为『私有』的方法归入名叫Private的分类中，以隐藏实现细节。</li></ul><h3 id="第25条-总是为第三方类的分类名称加前缀"><a href="#第25条-总是为第三方类的分类名称加前缀" class="headerlink" title="第25条 总是为第三方类的分类名称加前缀"></a>第25条 总是为第三方类的分类名称加前缀</h3><ul><li>向第三方类中添加分类时，总应给其名称加上你专用的前缀。</li><li>向第三方类中添加分类时，总应给其中的方法名加上你专用的前缀。</li></ul><h3 id="第26条-勿在分类中声明属性"><a href="#第26条-勿在分类中声明属性" class="headerlink" title="第26条 勿在分类中声明属性"></a>第26条 勿在分类中声明属性</h3><ul><li>把封装数据所用的全部属性都定义在主接口里。</li><li>在『class-continuation分类』之外的其他分类中，可以定义存取方法，但尽量不要定义属性。</li></ul><h3 id="第27条-使用『class-continuation分类』隐藏实现细节"><a href="#第27条-使用『class-continuation分类』隐藏实现细节" class="headerlink" title="第27条 使用『class-continuation分类』隐藏实现细节"></a>第27条 使用『class-continuation分类』隐藏实现细节</h3><ul><li>通过『class-continuation分类』向类中新增实例变量。</li><li>如果某属性在主接口中声明为『只读』，而类的内部又要用设置方法修改此属性，那么就在『class-continuation分类』中将其扩展为『可读写』。</li><li>把私有方法的原型声明在『class-continuation分类』里面。</li><li>若想使类所遵循的协议不为人所知，则可于『class-continuation分类』中声明。</li></ul><h3 id="第28条-通过协议提供匿名对象"><a href="#第28条-通过协议提供匿名对象" class="headerlink" title="第28条 通过协议提供匿名对象"></a>第28条 通过协议提供匿名对象</h3><ul><li>协议可在某种程度上提供匿名类型，具体的对象类型可以淡化成遵从某协议的 id 类型，协议里规定了对象所应实现的方法。</li><li>使用匿名对象来隐藏类型名称（或类名）。</li><li>使用具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可使用匿名对象来表示。</li></ul><h2 id="第5章-内存管理"><a href="#第5章-内存管理" class="headerlink" title="第5章 内存管理"></a>第5章 内存管理</h2><h3 id="第29条-理解引用计数"><a href="#第29条-理解引用计数" class="headerlink" title="第29条 理解引用计数"></a>第29条 理解引用计数</h3><ul><li>引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁了。</li><li>在对象生命期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。</li></ul><h3 id="第30条-以-ARC-简化引用计数"><a href="#第30条-以-ARC-简化引用计数" class="headerlink" title="第30条 以 ARC 简化引用计数"></a>第30条 以 ARC 简化引用计数</h3><ul><li>有 ARC 之后，程序员就无须担心内存管理问题了。使用 ARC 来编程，可省去类中的许多『样板代码』。</li><li>ARC 管理对象生命期的办法基本上就是：在合适的地方插入『保留』及『释放』操作。在 ARC 环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行『保留』及『释放』操作。</li><li>由方法返回的对象，其内存管理语义总是通过方法名来体现。 ARC 将此确定为开发者必须遵守的规则。</li><li>ARC 只负责管理 Objective-C 对象的内存。尤其要注意：CoreFoundation 对象不归ARC 管理，开发者必须适时调用 CFRetain/CFRelease。</li></ul><h3 id="第31条-在-dealloc-方法中只释放引用并解除监听"><a href="#第31条-在-dealloc-方法中只释放引用并解除监听" class="headerlink" title="第31条 在 dealloc 方法中只释放引用并解除监听"></a>第31条 在 dealloc 方法中只释放引用并解除监听</h3><ul><li>在 dealloc 方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的『键值观测』（KVO）或 NSNotificationCenter 等通知，不要做其他事情。</li><li>如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用 close 方法。</li><li>执行异步任务的方法不应在 dealloc 里调用；只能在正常状态下执行的那些方法也不应在dealloc里调用，因为此时对象已处于正在回收的状态了。</li></ul><h3 id="第32条-编写『异常安全代码』时留意内存管理问题"><a href="#第32条-编写『异常安全代码』时留意内存管理问题" class="headerlink" title="第32条 编写『异常安全代码』时留意内存管理问题"></a>第32条 编写『异常安全代码』时留意内存管理问题</h3><ul><li>捕获异常时，一定要注意将 try 块内所创立的对象清理干净。</li><li>在默认情况下，ARC 不生成安全处理异常所需的清理代码，开启编译器标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。</li></ul><h3 id="第33条-以弱引用避免保留环"><a href="#第33条-以弱引用避免保留环" class="headerlink" title="第33条 以弱引用避免保留环"></a>第33条 以弱引用避免保留环</h3><ul><li>将某些引用设为 weak，可避免出现『保留环』。</li><li>weak 引用可以自动清空，也可以不自动清空。自动清空（autonilling）是随着 ARC 而引入的新特性，由运行期系统来实现。在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象。</li></ul><h3 id="第34条-以『自动释放池块』降低内存峰值"><a href="#第34条-以『自动释放池块』降低内存峰值" class="headerlink" title="第34条 以『自动释放池块』降低内存峰值"></a>第34条 以『自动释放池块』降低内存峰值</h3><ul><li>自动释放池排布在栈中，对象收到 autorelease 消息后，系统将其放入最顶端的池里。</li><li>合理运用自动释放池，可降低应用程序的内存峰值。</li><li>@autoreleasepool 这种新式写法能创建出更为轻便的自动释放池。</li></ul><h3 id="第35条-用『僵尸对象』调试内存管理问题"><a href="#第35条-用『僵尸对象』调试内存管理问题" class="headerlink" title="第35条 用『僵尸对象』调试内存管理问题"></a>第35条 用『僵尸对象』调试内存管理问题</h3><ul><li>系统在回收对象时，可以不将其真的回收，而是把它转化为僵尸对象。通过环境变量 NSZombieEnabled 可开启此功能。</li><li>系统会修改对象的 isa 指针，令其指向特殊的僵尸类，从而使该对象变成僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序。</li></ul><h3 id="第36条-不要使用-retainCount"><a href="#第36条-不要使用-retainCount" class="headerlink" title="第36条 不要使用 retainCount"></a>第36条 不要使用 retainCount</h3><ul><li>对象的保留计数看似有用，实则不然，因为任何给定时间点上的『绝对保留计数』（absolute retain count）都无法反映对象生命期的全貌。</li><li>引入 ARC 之后，retainCount 方法就正式废止了，在 ARC 下调用该方法会导致编译器报错。</li></ul><h2 id="第6章-块（block）与大中枢派发（GCD）"><a href="#第6章-块（block）与大中枢派发（GCD）" class="headerlink" title="第6章 块（block）与大中枢派发（GCD）"></a>第6章 块（block）与大中枢派发（GCD）</h2><h3 id="第37条-理解『块』这一概念"><a href="#第37条-理解『块』这一概念" class="headerlink" title="第37条 理解『块』这一概念"></a>第37条 理解『块』这一概念</h3><ul><li>块是C、C++、Objective-C 中的词法闭包。</li><li>块可接受参数，也可返回值。</li><li>块可以分配在栈或堆上，也可以是全局的。分配在栈上的块可拷贝到堆里，这样的话，就和标准的 Objective-C 对象一样，具备引用计数了。</li></ul><h3 id="第38条-为常用的块类型创建-typedef"><a href="#第38条-为常用的块类型创建-typedef" class="headerlink" title="第38条 为常用的块类型创建 typedef"></a>第38条 为常用的块类型创建 typedef</h3><ul><li>以 typedef 重新定义块类型，可令块变量用起来更加简单。</li><li>定义新类型时应遵从现有的命名习惯，勿使其名称与别的类型相冲突。</li><li>不妨为同一个块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名，那么只需修改相应 typedef 中的块签名即可，无须改动其他 typedef。</li></ul><h3 id="第39条-用-handler-块降低代码分散程度"><a href="#第39条-用-handler-块降低代码分散程度" class="headerlink" title="第39条 用 handler 块降低代码分散程度"></a>第39条 用 handler 块降低代码分散程度</h3><ul><li>在创建对象时，可以使用内联的 handler 块将相关业务逻辑一并声明。</li><li>在有多个实例需要监控时，如果采用委托模式，那么经常需要根据传入的对象来切换，而若改用 handler 块来实现，则可直接将块与相关对象放在一起。</li><li>设计 API 时如果用到了 handler 块，那么可以增加一个参数，使调用者可通过此参数来决定应该把块安排在哪个队列上执行。</li></ul><h3 id="第40条-用块引用其所属对象时不要出现保留环"><a href="#第40条-用块引用其所属对象时不要出现保留环" class="headerlink" title="第40条 用块引用其所属对象时不要出现保留环"></a>第40条 用块引用其所属对象时不要出现保留环</h3><ul><li>如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题。</li><li>一定要找个适当的时机解除保留环，而不能把责任推给API的调用者。</li></ul><h3 id="第41条-多用派发队列，少用同步锁"><a href="#第41条-多用派发队列，少用同步锁" class="headerlink" title="第41条 多用派发队列，少用同步锁"></a>第41条 多用派发队列，少用同步锁</h3><ul><li>派发队列可用来表述同步语义（synchronization semantic），这种做法要比使用 @synchronized 块或 NSLock 对象更简单。</li><li>将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。</li><li>使用同步队列及栅栏块，可以令同步行为更加高效。</li></ul><h3 id="第42条-多用-GCD，少用-performSelector-系列方法"><a href="#第42条-多用-GCD，少用-performSelector-系列方法" class="headerlink" title="第42条 多用 GCD，少用 performSelector 系列方法"></a>第42条 多用 GCD，少用 performSelector 系列方法</h3><ul><li>performSelector 系列方法在内存管理方面容易有疏失。它无法确定将要执行的选择子具体是什么，因而 ARC 编译器也就无法插入适当的内存管理方法。</li><li>performSelector 系列方法所能处理的选择子太过局限了，选择子的返回值类型及发送给方法的参数个数都受到限制。</li><li>如果想把任务放在另一个线程上执行，那么最好不要用 performSelector 系列方法，而是应该把任务封装到块里，然后调用大中枢派发机制的相关方法来实现。</li></ul><h3 id="第43条-掌握-GCD-及操作队列的使用时机"><a href="#第43条-掌握-GCD-及操作队列的使用时机" class="headerlink" title="第43条 掌握 GCD 及操作队列的使用时机"></a>第43条 掌握 GCD 及操作队列的使用时机</h3><ul><li>在解决多线程与任务管理问题时，派发队列并非唯一方案。</li><li>操作队列提供了一套高层的 Objective-C API，能实现纯 GCD 所具备的绝大部分功能，而且还能完成一些更为复杂的操作，那些操作若改用 GCD 来实现，则需另外编写代码。</li></ul><h3 id="第44条-通过-Dispatch-Group-机制，根据系统资源状况来执行任务"><a href="#第44条-通过-Dispatch-Group-机制，根据系统资源状况来执行任务" class="headerlink" title="第44条 通过 Dispatch Group 机制，根据系统资源状况来执行任务"></a>第44条 通过 Dispatch Group 机制，根据系统资源状况来执行任务</h3><ul><li>一系列任务可归入一个 dispatch group 之中。开发者可以在这组任务执行完毕时获得通知。</li><li>通过 dispatch group，可以在并发式派发队列里同时执行多项任务。此时 GCD 会根据系统资源状况来调度这些并发执行的任务。开发者若自己来实现此功能，则需编写大量代码。</li></ul><h3 id="第45条-使用-dispatch-once-来执行只需运行一次的线程安全代码"><a href="#第45条-使用-dispatch-once-来执行只需运行一次的线程安全代码" class="headerlink" title="第45条 使用 dispatch_once 来执行只需运行一次的线程安全代码"></a>第45条 使用 dispatch_once 来执行只需运行一次的线程安全代码</h3><ul><li>经常需要编写『只需执行一次的线程安全代码』（thread-safe single-code execution）。通过 GCD 所提供的 dispatch_once 函数，很容易就能实现此功能。</li><li>标记应该声明在 static 或 global 作用域中，这样的话，在把只需执行一次的块传给 dispatch_once 函数时，传进去的标记也是相同的。</li></ul><h3 id="第46条-不要使用-dispatch-get-current-queue"><a href="#第46条-不要使用-dispatch-get-current-queue" class="headerlink" title="第46条 不要使用 dispatch_get_current_queue"></a>第46条 不要使用 dispatch_get_current_queue</h3><ul><li>dispatch_get_current_queue 函数的行为常常与开发者所预期的不同。此函数已经废弃，只应做调试之用。</li><li>由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述『当前队列』这一概念。</li><li>dispatch_get_current_queue 函数用于解决由不可重入的代码所引发的死锁，然而能用此函数解决的问题，通常也能改用『队列特定数据』来解决。</li></ul><h2 id="第7章-系统框架"><a href="#第7章-系统框架" class="headerlink" title="第7章 系统框架"></a>第7章 系统框架</h2><h3 id="第47条-熟悉系统框架"><a href="#第47条-熟悉系统框架" class="headerlink" title="第47条 熟悉系统框架"></a>第47条 熟悉系统框架</h3><ul><li>许多系统框架都可以直接使用。其中最重要的是 Foundation 和 CoreFoundation，这两个框架提供了构建应用程序所需的许多核心功能。</li><li>很多常见任务都能用框架来做，例如音频与视频处理、网络通信、数据管理等。</li><li>请记住：用纯 C 写成的框架与用 Objective-C 写成的一样重要，若想成为优秀的 Objective-C 开发者，应该掌握 C 语言的核心概念。</li></ul><h3 id="第48条-多用块枚举，少用-for-循环"><a href="#第48条-多用块枚举，少用-for-循环" class="headerlink" title="第48条 多用块枚举，少用 for 循环"></a>第48条 多用块枚举，少用 for 循环</h3><ul><li>遍历 collection 有四种方式。最基本的办法是 for 循环，其次是 NSEnumerator 遍历法及快速遍历法，最新、最先进的方式则是『块枚举法』。</li><li>『块枚举法』本身就能通过 GCD 来并发执行遍历操作，无须另行编写代码。而采用其他遍历方式则无法轻易实现这一点。</li><li>若提前知道待遍历的 collection 含有何种对象，则应修改块签名，指出对象的具体类型。</li></ul><h3 id="第49条-对自定义其内存管理语义的-collection-使用无缝桥接"><a href="#第49条-对自定义其内存管理语义的-collection-使用无缝桥接" class="headerlink" title="第49条 对自定义其内存管理语义的 collection 使用无缝桥接"></a>第49条 对自定义其内存管理语义的 collection 使用无缝桥接</h3><ul><li>通过无缝桥接技术，可以在 Foundation 框架中的 Objective-C 对象与 CoreFoundation 框架中的 C 语言数据结构之间来回转换。</li><li>在 CoreFoundation 层面创建 collection 时，可以指定许多回调函数，这些函数表示此 collection 应如何处理其元素。然后，可运用无缝桥接技术，将其转换成具备特殊内存管理语义的 Objective-C collection。</li></ul><h3 id="第50条-构建缓存时选用-NSCache-而非-NSDictionary"><a href="#第50条-构建缓存时选用-NSCache-而非-NSDictionary" class="headerlink" title="第50条 构建缓存时选用 NSCache 而非 NSDictionary"></a>第50条 构建缓存时选用 NSCache 而非 NSDictionary</h3><ul><li>实现缓存时应选用 NSCache 而非 NSDictionary 对象。因为 NSCache 可以提供优雅的自动删减功能，而且是『线程安全的』。此外，它与字典不同，并不会拷贝键。</li><li>可以给 NSCache 对象设置上限，用以限制缓存中的对象总个数及『总成本』。而这些尺度则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的『硬限制』（hard limit），它们仅对 NSCache 起指导作用。</li><li>将 NSPurgeableData 与 NSCache 搭配使用，可实现自动清除数据的功能，也就是说，当 NSPurgeableData 对象所占内存为系统所丢弃时，该对象自身也会从缓存中移除。</li><li>如果缓存使用的得当，那么应用程序的响应速度就能提高。只有那种『重新计算起来很费事的』数据，才值得放入缓存，比如那些需要从网络获取或从磁盘读取的数据。</li></ul><h3 id="第51条-精简-initialize-与-load-的实现代码"><a href="#第51条-精简-initialize-与-load-的实现代码" class="headerlink" title="第51条 精简 initialize 与 load 的实现代码"></a>第51条 精简 initialize 与 load 的实现代码</h3><ul><li>在加载阶段，如果类实现了 load 方法，那么系统就会调用它。分类里也可以定义此方法，类的 load 方法要比分类中的先调用。与其他方法不同，load 方法不参与覆写机制。</li><li>首次使用某个类之前，系统会向其发送 initialize 消息。由于此方法遵从普通的覆写规则，所以通常应该在里面判断当前要初始化的是那个类。</li><li>load 与 initialize 方法都应该实现得精简一些，这有助于保持应用程序的响应能力，也能减少引入『依赖环』（interdependency cycle）的几率。</li><li>无法在编译器设定的全局变量，可以放在 initialize 方法里初始化。</li></ul><h3 id="第52条-别忘了-NSTimer-会保留其目标对象"><a href="#第52条-别忘了-NSTimer-会保留其目标对象" class="headerlink" title="第52条 别忘了 NSTimer 会保留其目标对象"></a>第52条 别忘了 NSTimer 会保留其目标对象</h3><ul><li>NSTimer 对象会保留其目标，直到计时器本身失效为止，调用 invalidate 方法可令计时器失效，另外，一次性的计时器在触发完任务之后也会失效。</li><li>反复执行任务的计时器（repeating timer），很容易引入保留环，如果这种计时器的目标对象又保留了计时器本身，那肯定会导致保留环。这种环状保留关系，可能是直接发生的，也可能是通过对象图里的其他对象间接发生的。</li><li>可以扩充 NSTimer 的功能，用『块』来打破保留环。不过，除非 NSTimer 将来在公共接口里提供此功能，否则必须创建分类，将相关实现代码加入其中。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第1章-熟悉-Objective-C&quot;&gt;&lt;a href=&quot;#第1章-熟悉-Objective-C&quot; class=&quot;headerlink&quot; title=&quot;第1章 熟悉 Objective-C&quot;&gt;&lt;/a&gt;第1章 熟悉 Objective-C&lt;/h2&gt;&lt;h3 id=&quot;第1条-了解-Objective-C-语言的起源&quot;&gt;&lt;a href=&quot;#第1条-了解-Objective-C-语言的起源&quot; class=&quot;headerlink&quot; title=&quot;第1条 了解 Objective-C 语言的起源&quot;&gt;&lt;/a&gt;第1条 了解 Objective-C 语言的起源&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Objective-C 为C语言添加了面向对象特性，是其超集。Objective-C 使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定。&lt;/li&gt;
&lt;li&gt;理解C语言的核心概念有助于写好Objective-C程序。尤其要掌握内存模型与指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第2条-在类的头文件中尽量少引入其他头文件&quot;&gt;&lt;a href=&quot;#第2条-在类的头文件中尽量少引入其他头文件&quot; class=&quot;headerlink&quot; title=&quot;第2条 在类的头文件中尽量少引入其他头文件&quot;&gt;&lt;/a&gt;第2条 在类的头文件中尽量少引入其他头文件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合。&lt;/li&gt;
&lt;li&gt;有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把『该类遵循某协议』的这条声明移至『class-continuation分类』中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第3条-多用字面量语法，少用与之等价的方法&quot;&gt;&lt;a href=&quot;#第3条-多用字面量语法，少用与之等价的方法&quot; class=&quot;headerlink&quot; title=&quot;第3条 多用字面量语法，少用与之等价的方法&quot;&gt;&lt;/a&gt;第3条 多用字面量语法，少用与之等价的方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。&lt;/li&gt;
&lt;li&gt;应该通过取下标操作来访问数组下标或字典中的键所对应的元素。&lt;/li&gt;
&lt;li&gt;用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第4条-多用类型常量，少用-define-预处理指令&quot;&gt;&lt;a href=&quot;#第4条-多用类型常量，少用-define-预处理指令&quot; class=&quot;headerlink&quot; title=&quot;第4条 多用类型常量，少用 #define 预处理指令&quot;&gt;&lt;/a&gt;第4条 多用类型常量，少用 #define 预处理指令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。&lt;/li&gt;
&lt;li&gt;在实现文件中使用 static const 来定义『只在编译单元内可见的常量』（translation-unit-specific constant）。由于此类常量不在全局符号表中，所以无须为其名称加前缀。&lt;/li&gt;
&lt;li&gt;在头文件中使用 extern 来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所有其名称应加以区隔，通常用与之相关的类名做前缀。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第5条-用枚举表示状态、选项、状态码&quot;&gt;&lt;a href=&quot;#第5条-用枚举表示状态、选项、状态码&quot; class=&quot;headerlink&quot; title=&quot;第5条 用枚举表示状态、选项、状态码&quot;&gt;&lt;/a&gt;第5条 用枚举表示状态、选项、状态码&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。&lt;/li&gt;
&lt;li&gt;如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。&lt;/li&gt;
&lt;li&gt;用 NS_ENUM 与 NS_OPTIONS 宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。&lt;/li&gt;
&lt;li&gt;在处理枚举类型的 switch 语句中不要实现 default 分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch 语句并未处理所有枚举。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosky.tech/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://chaosky.tech/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>使用 R 进行数据分析</title>
    <link href="http://chaosky.tech/2016/11/07/Data-Analysis-With-R/"/>
    <id>http://chaosky.tech/2016/11/07/Data-Analysis-With-R/</id>
    <published>2016-11-07T04:42:41.000Z</published>
    <updated>2020-03-16T07:31:28.335Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="macOS-上搭建-R-开发环境"><a href="#macOS-上搭建-R-开发环境" class="headerlink" title="macOS 上搭建 R 开发环境"></a>macOS 上搭建 R 开发环境</h2><p>R 语言官方网站：<a href="https://www.r-project.org" target="_blank" rel="noopener">https://www.r-project.org</a></p><p>RStudio 官方网站：<a href="https://www.rstudio.com" target="_blank" rel="noopener">https://www.rstudio.com</a></p><p>RStudio 是 R 语言的IDE。</p><h3 id="安装包安装"><a href="#安装包安装" class="headerlink" title="安装包安装"></a>安装包安装</h3><ol><li><p>安装 XQuartz</p><p>下载地址：<a href="https://www.xquartz.org" target="_blank" rel="noopener">https://www.xquartz.org</a></p></li><li><p>安装 R</p><p>下载地址：<a href="https://cran.r-project.org" target="_blank" rel="noopener">https://cran.r-project.org</a></p></li><li><p>安装 RStudio</p><p>下载地址：<a href="https://www.rstudio.com/products/rstudio/download/" target="_blank" rel="noopener">https://www.rstudio.com/products/rstudio/download/</a></p></li></ol><h3 id="命令行安装"><a href="#命令行安装" class="headerlink" title="命令行安装"></a>命令行安装</h3><ol><li><p>安装 Homebrew</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br><span class="line">brew tap caskroom/cask</span><br><span class="line">brew install brew-cask</span><br><span class="line">brew update &amp;&amp; brew<span class="built_in"> upgrade </span>brew-cask &amp;&amp; brew cleanup &amp;&amp; brew cask cleanup</span><br></pre></td></tr></table></figure></li><li><p>安装 R 开发工具</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>cask install xquartz</span><br><span class="line"><span class="keyword">brew </span>tap homebrew/science</span><br><span class="line"><span class="keyword">brew </span>install R</span><br><span class="line"><span class="keyword">brew </span>cask install rstudio</span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据分析" scheme="http://chaosky.tech/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="R" scheme="http://chaosky.tech/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>【译】ARC 最佳实践</title>
    <link href="http://chaosky.tech/2016/11/04/ARC-Best-Practices/"/>
    <id>http://chaosky.tech/2016/11/04/ARC-Best-Practices/</id>
    <published>2016-11-04T01:06:04.000Z</published>
    <updated>2020-03-16T07:31:28.334Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>英文原文出处：<a href="http://amattn.com/p/arc_best_practices.html" target="_blank" rel="noopener">http://amattn.com/p/arc_best_practices.html</a></p><h2 id="一些可选背景故事："><a href="#一些可选背景故事：" class="headerlink" title="一些可选背景故事："></a>一些可选背景故事：</h2><ul><li>相关文档：<a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="noopener">迁移至ARC版本说明</a></li><li>Mike Ash 在他的 <a href="http://www.mikeash.com/pyblog/friday-qa-2011-09-30-automatic-reference-counting.html" target="_blank" rel="noopener">Friday Q&amp;As</a> 也有一篇关于ARC的文章。</li><li>深入的技术文档在 LLVM 项目的 <a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="noopener">CLANG 网站</a>上。</li></ul><p>假设你正在使用 iOS 5 或者更高版本，而不是 4。实际上，弱指针是 ARC 中的一个重要工具，所以我不建议在 iOS 4 中使用 ARC。</p><h2 id="更新注意事项"><a href="#更新注意事项" class="headerlink" title="更新注意事项"></a>更新注意事项</h2><p>这份文件自从2011年发布以来，一直在不断更新。最后一次微小的修订是在 2013年发布 iOS 7。</p><a id="more"></a><h2 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h2><ul><li><p>纯量类型属性应该使用 <strong>assign</strong>。</p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> scalarInt;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> scalarFloat;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGPoint</span> scalarStruct;</span><br></pre></td></tr></table></figure></li><li><p>需要保留或者引用向下对象层次结构的对象属性应该使用 <strong>strong</strong>。</p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> childObject;</span><br></pre></td></tr></table></figure></li><li><p>引用向上对象层次结构的对象属性应该使用 <strong>weak</strong>。此外，当引用委托对象时，<strong>weak</strong> 是最安全的。</p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> parentObject;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSObject</span> &lt;SomeDelegate&gt; *delegate;</span><br></pre></td></tr></table></figure></li><li><p><strong>Blocks</strong> 仍然应该使用 <strong>copy</strong>。</p>  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span><span class="title"> </span>(nonatomic, copy) SomeBlockType someBlock;</span><br></pre></td></tr></table></figure></li><li><p>在 <strong>dealloc</strong> 中：</p><ul><li>移除观察者</li><li>注销通知</li><li>设置所有不是 <strong>weak</strong> 的委托为 <strong>nil</strong></li><li>使所有定时器失效（译注：如果定时器是strong的属性，dealloc可能永远都不会被调用，所以定时器失效应该在ViewWillDisappear中完成）</li></ul></li><li><p><strong>IBOutlets</strong> 应该是 <strong>weak</strong>，除了顶层 <strong>IBOutlets</strong>是 <strong>strong</strong>。（译注：使用storyboard（xib不行）创建的vc，会有一个叫_topLevelObjectsToKeepAliveFromStoryboard的私有数组强引用所有top level的对象，所以这时即便outlet声明成weak也没关系）</p></li></ul><h2 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h2><p>官方文档：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> my_id;</span><br><span class="line"><span class="built_in">CFStringRef</span> my_cfref;</span><br><span class="line"><span class="built_in">NSString</span>   *a = (__bridge <span class="built_in">NSString</span>*)my_cfref;     <span class="comment">// Noop cast.</span></span><br><span class="line"><span class="built_in">CFStringRef</span> b = (__bridge <span class="built_in">CFStringRef</span>)my_id;      <span class="comment">// Noop cast.</span></span><br><span class="line"><span class="built_in">NSString</span>   *c = (__bridge_transfer <span class="built_in">NSString</span>*)my_cfref; <span class="comment">// -1 on the CFRef</span></span><br><span class="line"><span class="built_in">CFStringRef</span> d = (__bridge_retained <span class="built_in">CFStringRef</span>)my_id;  <span class="comment">// returned CFRef +1</span></span><br></pre></td></tr></table></figure><p>详细解释：</p><ul><li><strong>__bridge</strong> 对于内存管理是无操作的</li><li><strong>__bridge_transfer</strong> 用于转换 CFRef 为 Objective-C 对象。ARC 将减少 CFRef 的retain count，因此请确保 CFRef 具有+1 retain count。</li><li><strong>__bridge_retained</strong> 用于转换 Objective-C 对象为 CFRef。这将有效地给你返回一个 retain count +1的CFRef。 您有责任在未来某个时候调用 CFRef 的 CFRelease。</li></ul><h2 id="NSError"><a href="#NSError" class="headerlink" title="NSError"></a>NSError</h2><p>无处不在的 <strong>NSError</strong> 是有点棘手。典型的 Cocoa 约定是它们通过输出参数（也称为间接指针）实现。</p><p>在ARC中，输出参数默认是 <strong>__autoreleasing</strong>，应该这样实现:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)performWithError:(__autoreleasing <span class="built_in">NSError</span> **)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... some error occurs ...</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write to the out-parameter, ARC will autorelease it</span></span><br><span class="line">        *error = [[<span class="built_in">NSError</span> alloc] initWithDomain:<span class="string">@""</span> </span><br><span class="line">                                            code:<span class="number">-1</span> </span><br><span class="line">                                        userInfo:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用输出参数时，你应该在 <strong>*error</strong> 对象使用 <strong>__autoreleasing</strong>。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSError __autoreleasing *error = <span class="built_in">error</span>;</span><br><span class="line"><span class="keyword">BOOL</span> OK = [myObject performOperationWithError:&amp;<span class="built_in">error</span>];</span><br><span class="line"><span class="keyword">if</span> (!OK)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// handle the error.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你忘记 <strong>__autoreleasing</strong>，编译器将会简单地为你插入一个临时的中间自动释放对象。 这是在向后兼容性的压迫性制度下作出的妥协。我看到一些编译器配置不会自动使它们<strong>__autoreleasing</strong>。 对所有新代码包含 <strong>__autoreleasing</strong> 更安全的。</p><h2 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="@autoreleasepool"></a>@autoreleasepool</h2><p>使用 <strong>@autoreleasepool</strong> 内部循环：</p><ul><li>迭代很多，很多次</li><li>创建大量的临时对象</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If someArray is huge</span></span><br><span class="line"><span class="selector-tag">for</span> (id obj in someArray)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">@autoreleasepool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// or you are creating lots </span></span><br><span class="line">        <span class="comment">// of temporary objects here...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <strong>@autoreleasepool</strong> 指令创建和销毁自动释放池比蓝灯特价(译注：blue light special是沃尔玛的一个购物区域)还便宜。不要担心在循环中这样做。如果你超偏执，至少先检查profiler。</p><h2 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h2><p>一般来说，<strong>blocks</strong> 都能使用。但是有一些例外。</p><p>当将 <strong>block</strong> 指针添加到集合时，你首先得复制它们。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">someBlockType someBlock = ^&#123;NSLog(@<span class="string">"hi"</span>);&#125;;</span><br><span class="line">[someArray addObject:[someBlock <span class="keyword">copy</span><span class="bash">]];</span></span><br></pre></td></tr></table></figure><p><strong>blocks</strong> 的循环引用有些危险。你可能看到过这个警告：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">warning</span>: capturing <span class="string">'self'</span> strongly <span class="keyword">in</span> this </span><br><span class="line">block <span class="keyword">is</span> likely <span class="keyword">to</span> lead <span class="keyword">to</span> a retain <span class="keyword">cycle</span> </span><br><span class="line">[-Warc-retain-cycles,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">SomeBlockType someBlock = ^&#123;</span><br><span class="line">    [self someMethod];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因是 <strong>someBlock</strong> 被 self 强引用，并且当 <strong>block</strong> 拷贝到堆中时将捕获并且 retain  <strong>self</strong>。</p><p>使用任何实例变量也将捕获父对象，同样有不太明显的潜在循环引用：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The following block will retain "self"</span></span><br><span class="line">SomeBlockType someBlock = ^&#123;</span><br><span class="line">    <span class="keyword">BOOL</span> isDone = _isDone;  <span class="comment">// _isDone is an ivar of self</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更安全，但令人愉快的解决办法是使用 <strong>weakSelf</strong>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> SomeObjectClass *weakSelf = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">SomeBlockType someBlock = ^&#123;</span><br><span class="line">    SomeObjectClass *strongSelf = weakSelf;</span><br><span class="line">    <span class="keyword">if</span> (strongSelf == <span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The original self doesn't exist anymore.</span></span><br><span class="line">        <span class="comment">// Ignore, notify or otherwise handle this case.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        [strongSelf someMethod];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有时，你需要注意避免使用任意对象的循环引用：如果 <strong>someObject</strong> 强引用 <strong>someObject</strong> 的 <strong>block</strong>，你需要使用 <strong>weakSomeObject</strong> 打破循环引用。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SomeObjectClass *someObject = ...</span><br><span class="line"><span class="variable">__weak</span> SomeObjectClass *weakSomeObject = someObject;</span><br><span class="line"></span><br><span class="line">someObject.completionHandler = ^&#123;</span><br><span class="line">    SomeObjectClass *strongSomeObject = weakSomeObject;</span><br><span class="line">    <span class="keyword">if</span> (strongSomeObject == <span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The original someObject doesn't exist anymore.</span></span><br><span class="line">        <span class="comment">// Ignore, notify or otherwise handle this case.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// okay, NOW we can do something with someObject</span></span><br><span class="line">        [strongSomeObject someMethod];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="从NS对象或者UI对象访问CGRef"><a href="#从NS对象或者UI对象访问CGRef" class="headerlink" title="从NS对象或者UI对象访问CGRef"></a>从NS对象或者UI对象访问CGRef</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *redColor = [<span class="built_in">UIColor</span> redColor]; </span><br><span class="line"><span class="built_in">CGColorRef</span> redRef = redColor.CGColor;</span><br><span class="line"><span class="comment">// do some stuff with redRef.</span></span><br></pre></td></tr></table></figure><p>上面的例子有一些非常微妙的问题。当你创建 <strong>redRef</strong>，如果 <strong>redColor</strong> 不再使用，那么<strong>redColor</strong> 就在注释代码之后被销毁。</p><p>问题是 <strong>redColor</strong> 持有 <strong>redRef</strong>，并且当访问 <strong>redRef</strong>，它可能或者可能不再是 <strong>colorRef</strong>。更糟的是，这种类型的错误很少出现在模拟器上。当在较低工作内存的设备（比如：早期的iPad）上使用时，更有可能发生。</p><p>有几个解决办法。基本上都是当你在使用 <strong>redRef</strong> 时，保证 <strong>redColor</strong> 不会被释放。</p><p>一种非常简单的实现就是使用 <strong>__autoreleasing</strong>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> * __autoreleasing redColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"><span class="built_in">CGColorRef</span> redRef = redColor.CGColor;</span><br></pre></td></tr></table></figure><p>现在，<strong>redColor</strong> 不会被销毁，直到方法返回后某个不确定的时间，都能很好地使用。 我们可以安全地在方法的作用域使用 <strong>redRef</strong>。</p><p>另一个方法是 retain <strong>redRef</strong>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *redColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"><span class="built_in">CGColorRef</span> redRef = <span class="built_in">CFRetain</span>(redColor.CGColor);</span><br><span class="line"><span class="comment">// use redRef and when done release it:</span></span><br><span class="line"><span class="built_in">CFRelease</span>(redRef);</span><br></pre></td></tr></table></figure><p>重要提示：你需要 在使用<strong>redColor.CGColor</strong> 的同一行使用 <strong>CFRetain()</strong>。<strong>redColor</strong> 在上次使用之后有效地被破坏。以下方式不会有用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *redColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"><span class="built_in">CGColorRef</span> redRef = redColor.CGColor; <span class="comment">// redColor is released right after this...</span></span><br><span class="line"><span class="built_in">CFRetain</span>(redRef);  <span class="comment">// This may crash...</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面标有“This may crash”一行是一个有趣的注释。再次，我的经验里在模拟器上它不会经常崩溃，但在实际的iOS设备上100%崩溃。开发者请注意。</p><p>The Big Nerd Ranch 对这个问题有非常深入的探讨: <a href="http://weblog.bignerdranch.com/?p=296" target="_blank" rel="noopener">http://weblog.bignerdranch.com/?p=296</a></p><h2 id="Singletons"><a href="#Singletons" class="headerlink" title="Singletons"></a>Singletons</h2><p>仅仅偶然地与ARC有关。本地生成的单例实现是一种激增。（许多不必要的重写 retain 和 release）</p><p>这些都应该被替换为以下代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (MyClass *)singleton</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> MyClass *sharedMyClass = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;sharedMyClass = [[<span class="keyword">self</span> alloc] init];&#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedMyClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一次你需要销毁单例的能力。如果你使用这个除了 UnitTests，你可能不再使用单例。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare the static variable outside of the singleton method</span></span><br><span class="line"><span class="keyword">static</span> MyClass *__sharedMyClass = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">+ (MyClass *)singleton</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;__sharedMyClass = [[<span class="keyword">self</span> alloc] init];&#125;);</span><br><span class="line">    <span class="keyword">return</span> __sharedMyClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For use by test frameworks only!</span></span><br><span class="line">- (<span class="keyword">void</span>)destroyAndRecreateSingleton</span><br><span class="line">&#123;</span><br><span class="line">    __sharedMyClass = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="译者后记"><a href="#译者后记" class="headerlink" title="译者后记"></a>译者后记</h2><p>第一次翻译，请大家多多指教。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;英文原文出处：&lt;a href=&quot;http://amattn.com/p/arc_best_practices.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://amattn.com/p/arc_best_practices.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一些可选背景故事：&quot;&gt;&lt;a href=&quot;#一些可选背景故事：&quot; class=&quot;headerlink&quot; title=&quot;一些可选背景故事：&quot;&gt;&lt;/a&gt;一些可选背景故事：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;相关文档：&lt;a href=&quot;https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;迁移至ARC版本说明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mike Ash 在他的 &lt;a href=&quot;http://www.mikeash.com/pyblog/friday-qa-2011-09-30-automatic-reference-counting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Friday Q&amp;amp;As&lt;/a&gt; 也有一篇关于ARC的文章。&lt;/li&gt;
&lt;li&gt;深入的技术文档在 LLVM 项目的 &lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CLANG 网站&lt;/a&gt;上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设你正在使用 iOS 5 或者更高版本，而不是 4。实际上，弱指针是 ARC 中的一个重要工具，所以我不建议在 iOS 4 中使用 ARC。&lt;/p&gt;
&lt;h2 id=&quot;更新注意事项&quot;&gt;&lt;a href=&quot;#更新注意事项&quot; class=&quot;headerlink&quot; title=&quot;更新注意事项&quot;&gt;&lt;/a&gt;更新注意事项&lt;/h2&gt;&lt;p&gt;这份文件自从2011年发布以来，一直在不断更新。最后一次微小的修订是在 2013年发布 iOS 7。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosky.tech/categories/iOS/"/>
    
    
      <category term="ARC" scheme="http://chaosky.tech/tags/ARC/"/>
    
      <category term="译文" scheme="http://chaosky.tech/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Method Swizzle</title>
    <link href="http://chaosky.tech/2016/10/26/Objective-C-Method-Swizzle/"/>
    <id>http://chaosky.tech/2016/10/26/Objective-C-Method-Swizzle/</id>
    <published>2016-10-26T13:05:50.000Z</published>
    <updated>2020-03-16T07:31:28.333Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Method Swizzle（方法调配、方法混合、方法调和、方法混写） 是 Objective-C 运行时的黑魔法之一。我们可以通过 Swizzle 的手段，在运行时对某些方法的实现进行替换，这是 Objective-C 甚至说 Cocoa 开发中最为华丽，同时也是最为危险的技巧之一。Swizzle 使用了 Objective-C 的动态派发，对于 NSObject 的子类是可以直接使用的。</p><p>通过此方案，可以为那些『完全不知道其具体实现的』黑盒方法增加日志记录功能，这非常有助于程序调试。然而，次做法只在调试程序时有用。很少有人在调试程序之外的场合用上述『Method Swillze』来永久改动某个类的功能。不能仅仅因为Objective-C 语言里有这个特性就一定要用它。若是滥用，反而会令代码变得不易读懂且难于维护。</p><a id="more"></a><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><script src="https://gist.github.com/chaoskyme/4758787cda11d473c2abdf3ef5c63d67.js"></script><h2 id="示例demo"><a href="#示例demo" class="headerlink" title="示例demo"></a>示例demo</h2><p>demo 中实现了通过 Swizzle 的方式统计应用内所有按钮的点击次数。</p><p>代码下载地址：<a href="https://github.com/chaoskyme/Demo/tree/master/SwizzleDemo" target="_blank" rel="noopener">https://github.com/chaoskyme/Demo/tree/master/SwizzleDemo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Method Swizzle（方法调配、方法混合、方法调和、方法混写） 是 Objective-C 运行时的黑魔法之一。我们可以通过 Swizzle 的手段，在运行时对某些方法的实现进行替换，这是 Objective-C 甚至说 Cocoa 开发中最为华丽，同时也是最为危险的技巧之一。Swizzle 使用了 Objective-C 的动态派发，对于 NSObject 的子类是可以直接使用的。&lt;/p&gt;
&lt;p&gt;通过此方案，可以为那些『完全不知道其具体实现的』黑盒方法增加日志记录功能，这非常有助于程序调试。然而，次做法只在调试程序时有用。很少有人在调试程序之外的场合用上述『Method Swillze』来永久改动某个类的功能。不能仅仅因为Objective-C 语言里有这个特性就一定要用它。若是滥用，反而会令代码变得不易读懂且难于维护。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosky.tech/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://chaosky.tech/tags/Objective-C/"/>
    
      <category term="Runtime" scheme="http://chaosky.tech/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>地下城堡2：黑暗觉醒</title>
    <link href="http://chaosky.tech/2016/10/24/dungeon2/"/>
    <id>http://chaosky.tech/2016/10/24/dungeon2/</id>
    <published>2016-10-24T08:20:17.000Z</published>
    <updated>2020-03-16T07:31:28.332Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="地下城堡2：黑暗觉醒转职一览表"><a href="#地下城堡2：黑暗觉醒转职一览表" class="headerlink" title="地下城堡2：黑暗觉醒转职一览表"></a>地下城堡2：黑暗觉醒转职一览表</h2><p><img src="http://file.blog.chaosky.tech/2016-10-24-%E5%9C%B0%E4%B8%8B%E5%9F%8E%E5%A0%A12%EF%BC%9A%E9%BB%91%E6%9A%97%E8%A7%89%E9%86%92%E8%BD%AC%E8%81%8C%E4%B8%80%E8%A7%88%E8%A1%A8.png" alt="地下城堡2：黑暗觉醒转职一览表"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="玩游戏" scheme="http://chaosky.tech/categories/%E7%8E%A9%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="地下城堡2" scheme="http://chaosky.tech/tags/%E5%9C%B0%E4%B8%8B%E5%9F%8E%E5%A0%A12/"/>
    
  </entry>
  
  <entry>
    <title>越狱检测</title>
    <link href="http://chaosky.tech/2016/10/12/Check-Jailbroken/"/>
    <id>http://chaosky.tech/2016/10/12/Check-Jailbroken/</id>
    <published>2016-10-12T03:53:53.000Z</published>
    <updated>2020-03-16T07:31:28.331Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>代码详情查看以下</p><a id="more"></a><script src="https://gist.github.com/chaoskyme/12d9b72b65f55d0faf7d9690fa1a71b1.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码详情查看以下&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosky.tech/categories/iOS/"/>
    
    
      <category term="Jailbreak" scheme="http://chaosky.tech/tags/Jailbreak/"/>
    
  </entry>
  
  <entry>
    <title>iOS 持续集成</title>
    <link href="http://chaosky.tech/2016/09/26/Continuous-Integration/"/>
    <id>http://chaosky.tech/2016/09/26/Continuous-Integration/</id>
    <published>2016-09-26T15:00:51.000Z</published>
    <updated>2020-03-16T07:31:28.331Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>持续集成主要有两大好处：一是省去手动构建部署的繁琐，二是每一个提交都有自动跑测试保证质量。</p><p>本文主要介绍两大持续集成工具：TravisCI 和 Jenkins。</p><h2 id="TravisCI"><a href="#TravisCI" class="headerlink" title="TravisCI"></a>TravisCI</h2><p>Travis CI 可以和 Github 无缝集成，每次push都可以触发相应的操作，跑测试、自动部署都能完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosky.tech/categories/iOS/"/>
    
    
      <category term="TravisCI" scheme="http://chaosky.tech/tags/TravisCI/"/>
    
      <category term="Jenkins" scheme="http://chaosky.tech/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>单例类</title>
    <link href="http://chaosky.tech/2016/09/24/Singteton-Class/"/>
    <id>http://chaosky.tech/2016/09/24/Singteton-Class/</id>
    <published>2016-09-24T12:09:24.000Z</published>
    <updated>2020-03-16T07:31:28.330Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>单例模式（Singleton Pattern）最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p>注意：</p><p>1、单例类只能有一个实例。</p><p>2、单例类必须自己创建自己的唯一实例。</p><p>3、单例类必须给所有其他对象提供这一实例。</p><a id="more"></a><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。<br>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。</p><p><img src="http://www.runoob.com/wp-content/uploads/2014/08/singleton_pattern_uml_diagram.jpg" alt=""></p><script src="https://gist.github.com/chaoskyme/23a6095423494752f3bee55c114a2a97.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;单例模式（Singleton Pattern）最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;/p&gt;
&lt;p&gt;这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1、单例类只能有一个实例。&lt;/p&gt;
&lt;p&gt;2、单例类必须自己创建自己的唯一实例。&lt;/p&gt;
&lt;p&gt;3、单例类必须给所有其他对象提供这一实例。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosky.tech/categories/iOS/"/>
    
    
      <category term="Singteton" scheme="http://chaosky.tech/tags/Singteton/"/>
    
  </entry>
  
  <entry>
    <title>我关注的公众号</title>
    <link href="http://chaosky.tech/2016/09/21/Official-Accounts/"/>
    <id>http://chaosky.tech/2016/09/21/Official-Accounts/</id>
    <published>2016-09-21T07:47:09.000Z</published>
    <updated>2020-03-16T07:31:28.329Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><h4 id="iOS开发"><a href="#iOS开发" class="headerlink" title="iOS开发"></a>iOS开发</h4><p>微信号：iOSDevTip</p><p>功能介绍：最新iOS、iPhone资讯，万名iOS开发者、swift开发、果粉聚集，参与技术讨论，整理开发技巧，分享创业经验！享受生活、热爱编程！</p><h4 id="CocoaChina"><a href="#CocoaChina" class="headerlink" title="CocoaChina"></a>CocoaChina</h4><p>微信号: cocoachinabbs</p><p>功能介绍: CocoaChina苹果开发中文社区官方微信，提供教程资源、app推广营销、招聘、外包及培训信息、各类沙龙交流活动以及更多开发者服务。</p><h4 id="Crossin的编程教室"><a href="#Crossin的编程教室" class="headerlink" title="Crossin的编程教室"></a>Crossin的编程教室</h4><p>微信号: crossincode</p><p>功能介绍: 每天5分钟，学点简单的编程，用新的思维方式看世界。</p><h4 id="待字闺中"><a href="#待字闺中" class="headerlink" title="待字闺中"></a>待字闺中</h4><p>微信号: daiziguizhongren</p><p>功能介绍: 深度分析大数据、深度学习、人工智能等技术，切中实际应用场景，为大家授业解惑。间或，也会介绍国内外相关领域有趣的面试题。</p><h4 id="程序人生"><a href="#程序人生" class="headerlink" title="程序人生"></a>程序人生</h4><p>微信号: programmer_life</p><p>功能介绍: 十年漫漫程序人生，打过各种杂，也做过让我骄傲的软件；管理过十多人的团队，还带领一班兄弟姐妹创过业。关注程序人生，了解程序猿，学做程序猿，让我们的人生不再屌丝化。</p><h4 id="唐巧——iOS开发"><a href="#唐巧——iOS开发" class="headerlink" title="唐巧——iOS开发"></a>唐巧——iOS开发</h4><p>微信号: iosDevTips</p><p>功能介绍: 我叫唐巧，InfoQ 编辑，《iOS开发进阶》作者，现在在猿题库创业。本账号主要分享我精选的 iOS 开发文章和一些创业感悟。</p><h4 id="利器"><a href="#利器" class="headerlink" title="利器"></a>利器</h4><p>微信号：liqiio</p><p>功能介绍：创造者和他们的工具.</p><h4 id="论码农的自我修养"><a href="#论码农的自我修养" class="headerlink" title="论码农的自我修养"></a>论码农的自我修养</h4><p>微信号：bit_tiger</p><p>功能介绍：“有趣,有用,有效”.刷项目,做实战,捅破技术的那层纸.</p><h4 id="Pinapps"><a href="#Pinapps" class="headerlink" title="Pinapps"></a>Pinapps</h4><p>微信号：Pinapps</p><p>功能介绍：我推荐的不仅是apps,更是一种态度!</p><h4 id="ThoughtWorks"><a href="#ThoughtWorks" class="headerlink" title="ThoughtWorks"></a>ThoughtWorks</h4><p>微信号：ThoughtWorks</p><p>功能介绍：最新技术雷达/各类技术干货/精选职位招聘/精彩活动预告/经典案例故事,就在ThoughtWorks.</p><h3 id="人文"><a href="#人文" class="headerlink" title="人文"></a>人文</h3><h4 id="不止读书"><a href="#不止读书" class="headerlink" title="不止读书"></a>不止读书</h4><p>微信号: buzhidushu</p><p>功能介绍: 不止读书，读书不止。推荐好书。</p><h4 id="伯乐在线"><a href="#伯乐在线" class="headerlink" title="伯乐在线"></a>伯乐在线</h4><p>微信号: jobbole</p><p>功能介绍：关注职业资讯；学习各类职业感悟、心得和经验分享，扩大职业视野；体会求职、工作和创业的历程 - 就在JobBole.com 伯乐在线</p><h4 id="槽边往事"><a href="#槽边往事" class="headerlink" title="槽边往事"></a>槽边往事</h4><p>微信号: bitsea</p><p>功能介绍: 和菜头的微信Blog，用于分享各种新鲜资讯</p><h4 id="鬼脚七"><a href="#鬼脚七" class="headerlink" title="鬼脚七"></a>鬼脚七</h4><p>微信号: taobaoguijiaoqi</p><p>功能介绍: 鬼脚七，真名文德，自媒体人。做自己，爱生活！</p><h4 id="懒人在思考"><a href="#懒人在思考" class="headerlink" title="懒人在思考"></a>懒人在思考</h4><p>微信号：lazy-thought</p><p>功能介绍：以黑客那种邪气看待世界.而你,务必保持自己的独立思维. By 余弦</p><h4 id="老鹰说"><a href="#老鹰说" class="headerlink" title="老鹰说"></a>老鹰说</h4><p>微信号：joeytalks</p><p>功能介绍：创业就是典当灵魂,成功者才能将灵魂赎回.老鹰在这里与你分享赎回灵魂路上的点点滴滴.</p><h4 id="连岳"><a href="#连岳" class="headerlink" title="连岳"></a>连岳</h4><p>微信号：ilianyue</p><p>功能介绍：连岳文字，当今中国最活跃的专栏作家之一,著名专栏《我爱问连岳》</p><h4 id="罗辑思维"><a href="#罗辑思维" class="headerlink" title="罗辑思维"></a>罗辑思维</h4><p>微信号：luojisw</p><p>功能介绍：罗胖每天早上60秒语音,用文字回复语音中的关键词可阅读文章.</p><h4 id="MacTalk"><a href="#MacTalk" class="headerlink" title="MacTalk"></a>MacTalk</h4><p>微信号：sagacity-mac</p><p>功能介绍：MacTalk 开通于2012年末,内容起于 Mac 而不止 Mac,内容覆盖了技术、创业、产品和人文思考.文风有趣,又有一点力量.相关图书《MacTalk·人生元编程》《MacTalk·跨越边界》</p><h4 id="厉哥——虚拟机"><a href="#厉哥——虚拟机" class="headerlink" title="厉哥——虚拟机"></a>厉哥——虚拟机</h4><p>微信号：mintshow</p><p>功能介绍：毫无悬念最值得关注的账号.世界上牛人有无数,而厉哥只有一个.</p><h4 id="三表龙门阵"><a href="#三表龙门阵" class="headerlink" title="三表龙门阵"></a>三表龙门阵</h4><p>微信号：sanbiao1984</p><p>功能介绍：负责吐槽一切!互联网大喷壶,大嘴善喷喷天下可喷之事!</p><h4 id="神秘的程序员们"><a href="#神秘的程序员们" class="headerlink" title="神秘的程序员们"></a>神秘的程序员们</h4><p>微信号：coderstory</p><p>功能介绍：作为一个程序员星人,在地球上工作生活时,你是否会感到孤独呢? 这里有来自程序员母星的亲切问候和地球漫游指南.国内首部以程序员文化、技术主题、项目管理及互联网创业的为主题漫画,诞生于09年.主创:西乔、…</p><h4 id="Tiny4Voice"><a href="#Tiny4Voice" class="headerlink" title="Tiny4Voice"></a>Tiny4Voice</h4><p>微信号：tiny4voice</p><p>功能介绍：一天一条来自 Tinyfool 的语音鸡汤,暖胃暖心,让我们一起在漫漫长夜里面默默前行,在死之前,没有终点,不会停歇.</p><h4 id="图灵访谈"><a href="#图灵访谈" class="headerlink" title="图灵访谈"></a>图灵访谈</h4><p>微信号：ituring_interview</p><p>功能介绍：对话国外知名技术作者,讲述国内码农精彩人生.你听得见他们,他们也听得见你.</p><h4 id="图灵教育"><a href="#图灵教育" class="headerlink" title="图灵教育"></a>图灵教育</h4><p>微信号：turingbooks</p><p>功能介绍：是好书,把我们联系在一起</p><h4 id="歪理邪说"><a href="#歪理邪说" class="headerlink" title="歪理邪说"></a>歪理邪说</h4><p>微信号：wxieshuo</p><p>功能介绍：一切关于未来的故事在实现之前都是歪理邪说.</p><h4 id="我和世界之间"><a href="#我和世界之间" class="headerlink" title="我和世界之间"></a>我和世界之间</h4><p>微信号：between_world_and_me</p><p>功能介绍：更有品位 · 更有智慧 Better Taste · Wiser Life</p><h4 id="小道消息"><a href="#小道消息" class="headerlink" title="小道消息"></a>小道消息</h4><p>微信号：WebNotes</p><p>功能介绍：在这里,我想为你呈现一副中国互联网的清明上河图.冯大辉,丁香园技术产品负责人.</p><h4 id="余晟以为"><a href="#余晟以为" class="headerlink" title="余晟以为"></a>余晟以为</h4><p>微信号：yurii-says</p><p>功能介绍：我是这么以为的,当然你也可以那么以为</p><h3 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h3><h4 id="桂辉最久"><a href="#桂辉最久" class="headerlink" title="桂辉最久"></a>桂辉最久</h4><p>微信号: queendrunk</p><p>功能介绍: 原创+精选的科技类账号，干货分享TMT领域的行业热点、产品设计、大数据、市场趋势、商业模式、创业的深度分析和经典案例。第一大自媒体联盟WeMedia成员。</p><h4 id="InfoQ"><a href="#InfoQ" class="headerlink" title="InfoQ"></a>InfoQ</h4><p>微信号: infoqchina</p><p>功能介绍: 有内容的技术社区媒体</p><h4 id="极客公园"><a href="#极客公园" class="headerlink" title="极客公园"></a>极客公园</h4><p>微信号: geekpark</p><p>功能介绍: 科技创新者的大本营。汇聚优秀的产品报道、评测视频和高质量的线下活动。</p><h4 id="极客邦科技Geekbang"><a href="#极客邦科技Geekbang" class="headerlink" title="极客邦科技Geekbang"></a>极客邦科技Geekbang</h4><p>微信号: geekbang01</p><p>功能介绍: 极客邦科技是一家IT技术学习服务综合提供商，使命是帮助技术人和企业成长，旗下运营InfoQ技术媒体、EGO社交网络、StuQ在线教育、GIT企业培训等四大业务品牌，通过帮助技术人成长来推动企业发展。</p><h4 id="可能吧"><a href="#可能吧" class="headerlink" title="可能吧"></a>可能吧</h4><p>微信号: knbknb</p><p>功能介绍: 「可能吧」是一个诞生于2007年的博客，在2009年获得搜狐 IT 新闻奖、2010年获得德国之声最佳中文博客奖之后，因为众所周知的原因无法在中国访问。现在，它以另一种姿态存在。「可能吧」更新频率不高，文章一般不怎么客观，请谨慎关注。</p><h4 id="PingWest中文网"><a href="#PingWest中文网" class="headerlink" title="PingWest中文网"></a>PingWest中文网</h4><p>微信号：wepingwest</p><p>功能介绍：有品好玩的科技,一切与你有关。科技博客PingWest中文网(pingwest.com)</p><h4 id="商业价值"><a href="#商业价值" class="headerlink" title="商业价值"></a>商业价值</h4><p>微信号：bvmagazine</p><p>功能介绍：中国最好的技术商业杂志,关注更创新,更智慧,更可持续的商业,专为变革者打造.</p><h4 id="深圳湾"><a href="#深圳湾" class="headerlink" title="深圳湾"></a>深圳湾</h4><p>微信号：shenzhenware</p><p>功能介绍：深圳湾(ShenzhenWare)关注软件、硬件、以及软硬结合的生态系统.</p><h4 id="100offer说"><a href="#100offer说" class="headerlink" title="100offer说"></a>100offer说</h4><p>微信号：shuo100offer</p><p>功能介绍：有关互联网人才流动和发展,我们触摸得到真实客观的跳槽数据,我们感受得到有血有肉的故事.我们在观察,我们也在思考,我们在这里「说」</p><h4 id="36氪"><a href="#36氪" class="headerlink" title="36氪"></a>36氪</h4><p>微信号：wow36kr</p><p>功能介绍：36氪(36kr.com)是中国最具影响力的互联网创投媒体,提供最新锐最具深度的商业报道.我们强调趋势与价值,我们的slogan是:让一部分人先看到未来.</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;微信公众号&quot;&gt;&lt;a href=&quot;#微信公众号&quot; class=&quot;headerlink&quot; title=&quot;微信公众号&quot;&gt;&lt;/a&gt;微信公众号&lt;/h2&gt;&lt;h3 id=&quot;技术&quot;&gt;&lt;a href=&quot;#技术&quot; class=&quot;headerlink&quot; title=&quot;技术&quot;&gt;&lt;/a&gt;技术&lt;/h3&gt;&lt;h4 id=&quot;iOS开发&quot;&gt;&lt;a href=&quot;#iOS开发&quot; class=&quot;headerlink&quot; title=&quot;iOS开发&quot;&gt;&lt;/a&gt;iOS开发&lt;/h4&gt;&lt;p&gt;微信号：iOSDevTip&lt;/p&gt;
&lt;p&gt;功能介绍：最新iOS、iPhone资讯，万名iOS开发者、swift开发、果粉聚集，参与技术讨论，整理开发技巧，分享创业经验！享受生活、热爱编程！&lt;/p&gt;
&lt;h4 id=&quot;CocoaChina&quot;&gt;&lt;a href=&quot;#CocoaChina&quot; class=&quot;headerlink&quot; title=&quot;CocoaChina&quot;&gt;&lt;/a&gt;CocoaChina&lt;/h4&gt;&lt;p&gt;微信号: cocoachinabbs&lt;/p&gt;
&lt;p&gt;功能介绍: CocoaChina苹果开发中文社区官方微信，提供教程资源、app推广营销、招聘、外包及培训信息、各类沙龙交流活动以及更多开发者服务。&lt;/p&gt;
&lt;h4 id=&quot;Crossin的编程教室&quot;&gt;&lt;a href=&quot;#Crossin的编程教室&quot; class=&quot;headerlink&quot; title=&quot;Crossin的编程教室&quot;&gt;&lt;/a&gt;Crossin的编程教室&lt;/h4&gt;&lt;p&gt;微信号: crossincode&lt;/p&gt;
&lt;p&gt;功能介绍: 每天5分钟，学点简单的编程，用新的思维方式看世界。&lt;/p&gt;
&lt;h4 id=&quot;待字闺中&quot;&gt;&lt;a href=&quot;#待字闺中&quot; class=&quot;headerlink&quot; title=&quot;待字闺中&quot;&gt;&lt;/a&gt;待字闺中&lt;/h4&gt;&lt;p&gt;微信号: daiziguizhongren&lt;/p&gt;
&lt;p&gt;功能介绍: 深度分析大数据、深度学习、人工智能等技术，切中实际应用场景，为大家授业解惑。间或，也会介绍国内外相关领域有趣的面试题。&lt;/p&gt;
&lt;h4 id=&quot;程序人生&quot;&gt;&lt;a href=&quot;#程序人生&quot; class=&quot;headerlink&quot; title=&quot;程序人生&quot;&gt;&lt;/a&gt;程序人生&lt;/h4&gt;&lt;p&gt;微信号: programmer_life&lt;/p&gt;
&lt;p&gt;功能介绍: 十年漫漫程序人生，打过各种杂，也做过让我骄傲的软件；管理过十多人的团队，还带领一班兄弟姐妹创过业。关注程序人生，了解程序猿，学做程序猿，让我们的人生不再屌丝化。&lt;/p&gt;
&lt;h4 id=&quot;唐巧——iOS开发&quot;&gt;&lt;a href=&quot;#唐巧——iOS开发&quot; class=&quot;headerlink&quot; title=&quot;唐巧——iOS开发&quot;&gt;&lt;/a&gt;唐巧——iOS开发&lt;/h4&gt;&lt;p&gt;微信号: iosDevTips&lt;/p&gt;
&lt;p&gt;功能介绍: 我叫唐巧，InfoQ 编辑，《iOS开发进阶》作者，现在在猿题库创业。本账号主要分享我精选的 iOS 开发文章和一些创业感悟。&lt;/p&gt;
&lt;h4 id=&quot;利器&quot;&gt;&lt;a href=&quot;#利器&quot; class=&quot;headerlink&quot; title=&quot;利器&quot;&gt;&lt;/a&gt;利器&lt;/h4&gt;&lt;p&gt;微信号：liqiio&lt;/p&gt;
&lt;p&gt;功能介绍：创造者和他们的工具.&lt;/p&gt;
&lt;h4 id=&quot;论码农的自我修养&quot;&gt;&lt;a href=&quot;#论码农的自我修养&quot; class=&quot;headerlink&quot; title=&quot;论码农的自我修养&quot;&gt;&lt;/a&gt;论码农的自我修养&lt;/h4&gt;&lt;p&gt;微信号：bit_tiger&lt;/p&gt;
&lt;p&gt;功能介绍：“有趣,有用,有效”.刷项目,做实战,捅破技术的那层纸.&lt;/p&gt;
&lt;h4 id=&quot;Pinapps&quot;&gt;&lt;a href=&quot;#Pinapps&quot; class=&quot;headerlink&quot; title=&quot;Pinapps&quot;&gt;&lt;/a&gt;Pinapps&lt;/h4&gt;&lt;p&gt;微信号：Pinapps&lt;/p&gt;
&lt;p&gt;功能介绍：我推荐的不仅是apps,更是一种态度!&lt;/p&gt;
&lt;h4 id=&quot;ThoughtWorks&quot;&gt;&lt;a href=&quot;#ThoughtWorks&quot; class=&quot;headerlink&quot; title=&quot;ThoughtWorks&quot;&gt;&lt;/a&gt;ThoughtWorks&lt;/h4&gt;&lt;p&gt;微信号：ThoughtWorks&lt;/p&gt;
&lt;p&gt;功能介绍：最新技术雷达/各类技术干货/精选职位招聘/精彩活动预告/经典案例故事,就在ThoughtWorks.&lt;/p&gt;
&lt;h3 id=&quot;人文&quot;&gt;&lt;a href=&quot;#人文&quot; class=&quot;headerlink&quot; title=&quot;人文&quot;&gt;&lt;/a&gt;人文&lt;/h3&gt;&lt;h4 id=&quot;不止读书&quot;&gt;&lt;a href=&quot;#不止读书&quot; class=&quot;headerlink&quot; title=&quot;不止读书&quot;&gt;&lt;/a&gt;不止读书&lt;/h4&gt;&lt;p&gt;微信号: buzhidushu&lt;/p&gt;
&lt;p&gt;功能介绍: 不止读书，读书不止。推荐好书。&lt;/p&gt;
&lt;h4 id=&quot;伯乐在线&quot;&gt;&lt;a href=&quot;#伯乐在线&quot; class=&quot;headerlink&quot; title=&quot;伯乐在线&quot;&gt;&lt;/a&gt;伯乐在线&lt;/h4&gt;&lt;p&gt;微信号: jobbole&lt;/p&gt;
&lt;p&gt;功能介绍：关注职业资讯；学习各类职业感悟、心得和经验分享，扩大职业视野；体会求职、工作和创业的历程 - 就在JobBole.com 伯乐在线&lt;/p&gt;
&lt;h4 id=&quot;槽边往事&quot;&gt;&lt;a href=&quot;#槽边往事&quot; class=&quot;headerlink&quot; title=&quot;槽边往事&quot;&gt;&lt;/a&gt;槽边往事&lt;/h4&gt;&lt;p&gt;微信号: bitsea&lt;/p&gt;
&lt;p&gt;功能介绍: 和菜头的微信Blog，用于分享各种新鲜资讯&lt;/p&gt;
&lt;h4 id=&quot;鬼脚七&quot;&gt;&lt;a href=&quot;#鬼脚七&quot; class=&quot;headerlink&quot; title=&quot;鬼脚七&quot;&gt;&lt;/a&gt;鬼脚七&lt;/h4&gt;&lt;p&gt;微信号: taobaoguijiaoqi&lt;/p&gt;
&lt;p&gt;功能介绍: 鬼脚七，真名文德，自媒体人。做自己，爱生活！&lt;/p&gt;
&lt;h4 id=&quot;懒人在思考&quot;&gt;&lt;a href=&quot;#懒人在思考&quot; class=&quot;headerlink&quot; title=&quot;懒人在思考&quot;&gt;&lt;/a&gt;懒人在思考&lt;/h4&gt;&lt;p&gt;微信号：lazy-thought&lt;/p&gt;
&lt;p&gt;功能介绍：以黑客那种邪气看待世界.而你,务必保持自己的独立思维. By 余弦&lt;/p&gt;
&lt;h4 id=&quot;老鹰说&quot;&gt;&lt;a href=&quot;#老鹰说&quot; class=&quot;headerlink&quot; title=&quot;老鹰说&quot;&gt;&lt;/a&gt;老鹰说&lt;/h4&gt;&lt;p&gt;微信号：joeytalks&lt;/p&gt;
&lt;p&gt;功能介绍：创业就是典当灵魂,成功者才能将灵魂赎回.老鹰在这里与你分享赎回灵魂路上的点点滴滴.&lt;/p&gt;
&lt;h4 id=&quot;连岳&quot;&gt;&lt;a href=&quot;#连岳&quot; class=&quot;headerlink&quot; title=&quot;连岳&quot;&gt;&lt;/a&gt;连岳&lt;/h4&gt;&lt;p&gt;微信号：ilianyue&lt;/p&gt;
&lt;p&gt;功能介绍：连岳文字，当今中国最活跃的专栏作家之一,著名专栏《我爱问连岳》&lt;/p&gt;
&lt;h4 id=&quot;罗辑思维&quot;&gt;&lt;a href=&quot;#罗辑思维&quot; class=&quot;headerlink&quot; title=&quot;罗辑思维&quot;&gt;&lt;/a&gt;罗辑思维&lt;/h4&gt;&lt;p&gt;微信号：luojisw&lt;/p&gt;
&lt;p&gt;功能介绍：罗胖每天早上60秒语音,用文字回复语音中的关键词可阅读文章.&lt;/p&gt;
&lt;h4 id=&quot;MacTalk&quot;&gt;&lt;a href=&quot;#MacTalk&quot; class=&quot;headerlink&quot; title=&quot;MacTalk&quot;&gt;&lt;/a&gt;MacTalk&lt;/h4&gt;&lt;p&gt;微信号：sagacity-mac&lt;/p&gt;
&lt;p&gt;功能介绍：MacTalk 开通于2012年末,内容起于 Mac 而不止 Mac,内容覆盖了技术、创业、产品和人文思考.文风有趣,又有一点力量.相关图书《MacTalk·人生元编程》《MacTalk·跨越边界》&lt;/p&gt;
&lt;h4 id=&quot;厉哥——虚拟机&quot;&gt;&lt;a href=&quot;#厉哥——虚拟机&quot; class=&quot;headerlink&quot; title=&quot;厉哥——虚拟机&quot;&gt;&lt;/a&gt;厉哥——虚拟机&lt;/h4&gt;&lt;p&gt;微信号：mintshow&lt;/p&gt;
&lt;p&gt;功能介绍：毫无悬念最值得关注的账号.世界上牛人有无数,而厉哥只有一个.&lt;/p&gt;
&lt;h4 id=&quot;三表龙门阵&quot;&gt;&lt;a href=&quot;#三表龙门阵&quot; class=&quot;headerlink&quot; title=&quot;三表龙门阵&quot;&gt;&lt;/a&gt;三表龙门阵&lt;/h4&gt;&lt;p&gt;微信号：sanbiao1984&lt;/p&gt;
&lt;p&gt;功能介绍：负责吐槽一切!互联网大喷壶,大嘴善喷喷天下可喷之事!&lt;/p&gt;
&lt;h4 id=&quot;神秘的程序员们&quot;&gt;&lt;a href=&quot;#神秘的程序员们&quot; class=&quot;headerlink&quot; title=&quot;神秘的程序员们&quot;&gt;&lt;/a&gt;神秘的程序员们&lt;/h4&gt;&lt;p&gt;微信号：coderstory&lt;/p&gt;
&lt;p&gt;功能介绍：作为一个程序员星人,在地球上工作生活时,你是否会感到孤独呢? 这里有来自程序员母星的亲切问候和地球漫游指南.国内首部以程序员文化、技术主题、项目管理及互联网创业的为主题漫画,诞生于09年.主创:西乔、…&lt;/p&gt;
&lt;h4 id=&quot;Tiny4Voice&quot;&gt;&lt;a href=&quot;#Tiny4Voice&quot; class=&quot;headerlink&quot; title=&quot;Tiny4Voice&quot;&gt;&lt;/a&gt;Tiny4Voice&lt;/h4&gt;&lt;p&gt;微信号：tiny4voice&lt;/p&gt;
&lt;p&gt;功能介绍：一天一条来自 Tinyfool 的语音鸡汤,暖胃暖心,让我们一起在漫漫长夜里面默默前行,在死之前,没有终点,不会停歇.&lt;/p&gt;
&lt;h4 id=&quot;图灵访谈&quot;&gt;&lt;a href=&quot;#图灵访谈&quot; class=&quot;headerlink&quot; title=&quot;图灵访谈&quot;&gt;&lt;/a&gt;图灵访谈&lt;/h4&gt;&lt;p&gt;微信号：ituring_interview&lt;/p&gt;
&lt;p&gt;功能介绍：对话国外知名技术作者,讲述国内码农精彩人生.你听得见他们,他们也听得见你.&lt;/p&gt;
&lt;h4 id=&quot;图灵教育&quot;&gt;&lt;a href=&quot;#图灵教育&quot; class=&quot;headerlink&quot; title=&quot;图灵教育&quot;&gt;&lt;/a&gt;图灵教育&lt;/h4&gt;&lt;p&gt;微信号：turingbooks&lt;/p&gt;
&lt;p&gt;功能介绍：是好书,把我们联系在一起&lt;/p&gt;
&lt;h4 id=&quot;歪理邪说&quot;&gt;&lt;a href=&quot;#歪理邪说&quot; class=&quot;headerlink&quot; title=&quot;歪理邪说&quot;&gt;&lt;/a&gt;歪理邪说&lt;/h4&gt;&lt;p&gt;微信号：wxieshuo&lt;/p&gt;
&lt;p&gt;功能介绍：一切关于未来的故事在实现之前都是歪理邪说.&lt;/p&gt;
&lt;h4 id=&quot;我和世界之间&quot;&gt;&lt;a href=&quot;#我和世界之间&quot; class=&quot;headerlink&quot; title=&quot;我和世界之间&quot;&gt;&lt;/a&gt;我和世界之间&lt;/h4&gt;&lt;p&gt;微信号：between_world_and_me&lt;/p&gt;
&lt;p&gt;功能介绍：更有品位 · 更有智慧 Better Taste · Wiser Life&lt;/p&gt;
&lt;h4 id=&quot;小道消息&quot;&gt;&lt;a href=&quot;#小道消息&quot; class=&quot;headerlink&quot; title=&quot;小道消息&quot;&gt;&lt;/a&gt;小道消息&lt;/h4&gt;&lt;p&gt;微信号：WebNotes&lt;/p&gt;
&lt;p&gt;功能介绍：在这里,我想为你呈现一副中国互联网的清明上河图.冯大辉,丁香园技术产品负责人.&lt;/p&gt;
&lt;h4 id=&quot;余晟以为&quot;&gt;&lt;a href=&quot;#余晟以为&quot; class=&quot;headerlink&quot; title=&quot;余晟以为&quot;&gt;&lt;/a&gt;余晟以为&lt;/h4&gt;&lt;p&gt;微信号：yurii-says&lt;/p&gt;
&lt;p&gt;功能介绍：我是这么以为的,当然你也可以那么以为&lt;/p&gt;
&lt;h3 id=&quot;资讯&quot;&gt;&lt;a href=&quot;#资讯&quot; class=&quot;headerlink&quot; title=&quot;资讯&quot;&gt;&lt;/a&gt;资讯&lt;/h3&gt;&lt;h4 id=&quot;桂辉最久&quot;&gt;&lt;a href=&quot;#桂辉最久&quot; class=&quot;headerlink&quot; title=&quot;桂辉最久&quot;&gt;&lt;/a&gt;桂辉最久&lt;/h4&gt;&lt;p&gt;微信号: queendrunk&lt;/p&gt;
&lt;p&gt;功能介绍: 原创+精选的科技类账号，干货分享TMT领域的行业热点、产品设计、大数据、市场趋势、商业模式、创业的深度分析和经典案例。第一大自媒体联盟WeMedia成员。&lt;/p&gt;
&lt;h4 id=&quot;InfoQ&quot;&gt;&lt;a href=&quot;#InfoQ&quot; class=&quot;headerlink&quot; title=&quot;InfoQ&quot;&gt;&lt;/a&gt;InfoQ&lt;/h4&gt;&lt;p&gt;微信号: infoqchina&lt;/p&gt;
&lt;p&gt;功能介绍: 有内容的技术社区媒体&lt;/p&gt;
&lt;h4 id=&quot;极客公园&quot;&gt;&lt;a href=&quot;#极客公园&quot; class=&quot;headerlink&quot; title=&quot;极客公园&quot;&gt;&lt;/a&gt;极客公园&lt;/h4&gt;&lt;p&gt;微信号: geekpark&lt;/p&gt;
&lt;p&gt;功能介绍: 科技创新者的大本营。汇聚优秀的产品报道、评测视频和高质量的线下活动。&lt;/p&gt;
&lt;h4 id=&quot;极客邦科技Geekbang&quot;&gt;&lt;a href=&quot;#极客邦科技Geekbang&quot; class=&quot;headerlink&quot; title=&quot;极客邦科技Geekbang&quot;&gt;&lt;/a&gt;极客邦科技Geekbang&lt;/h4&gt;&lt;p&gt;微信号: geekbang01&lt;/p&gt;
&lt;p&gt;功能介绍: 极客邦科技是一家IT技术学习服务综合提供商，使命是帮助技术人和企业成长，旗下运营InfoQ技术媒体、EGO社交网络、StuQ在线教育、GIT企业培训等四大业务品牌，通过帮助技术人成长来推动企业发展。&lt;/p&gt;
&lt;h4 id=&quot;可能吧&quot;&gt;&lt;a href=&quot;#可能吧&quot; class=&quot;headerlink&quot; title=&quot;可能吧&quot;&gt;&lt;/a&gt;可能吧&lt;/h4&gt;&lt;p&gt;微信号: knbknb&lt;/p&gt;
&lt;p&gt;功能介绍: 「可能吧」是一个诞生于2007年的博客，在2009年获得搜狐 IT 新闻奖、2010年获得德国之声最佳中文博客奖之后，因为众所周知的原因无法在中国访问。现在，它以另一种姿态存在。「可能吧」更新频率不高，文章一般不怎么客观，请谨慎关注。&lt;/p&gt;
&lt;h4 id=&quot;PingWest中文网&quot;&gt;&lt;a href=&quot;#PingWest中文网&quot; class=&quot;headerlink&quot; title=&quot;PingWest中文网&quot;&gt;&lt;/a&gt;PingWest中文网&lt;/h4&gt;&lt;p&gt;微信号：wepingwest&lt;/p&gt;
&lt;p&gt;功能介绍：有品好玩的科技,一切与你有关。科技博客PingWest中文网(pingwest.com)&lt;/p&gt;
&lt;h4 id=&quot;商业价值&quot;&gt;&lt;a href=&quot;#商业价值&quot; class=&quot;headerlink&quot; title=&quot;商业价值&quot;&gt;&lt;/a&gt;商业价值&lt;/h4&gt;&lt;p&gt;微信号：bvmagazine&lt;/p&gt;
&lt;p&gt;功能介绍：中国最好的技术商业杂志,关注更创新,更智慧,更可持续的商业,专为变革者打造.&lt;/p&gt;
&lt;h4 id=&quot;深圳湾&quot;&gt;&lt;a href=&quot;#深圳湾&quot; class=&quot;headerlink&quot; title=&quot;深圳湾&quot;&gt;&lt;/a&gt;深圳湾&lt;/h4&gt;&lt;p&gt;微信号：shenzhenware&lt;/p&gt;
&lt;p&gt;功能介绍：深圳湾(ShenzhenWare)关注软件、硬件、以及软硬结合的生态系统.&lt;/p&gt;
&lt;h4 id=&quot;100offer说&quot;&gt;&lt;a href=&quot;#100offer说&quot; class=&quot;headerlink&quot; title=&quot;100offer说&quot;&gt;&lt;/a&gt;100offer说&lt;/h4&gt;&lt;p&gt;微信号：shuo100offer&lt;/p&gt;
&lt;p&gt;功能介绍：有关互联网人才流动和发展,我们触摸得到真实客观的跳槽数据,我们感受得到有血有肉的故事.我们在观察,我们也在思考,我们在这里「说」&lt;/p&gt;
&lt;h4 id=&quot;36氪&quot;&gt;&lt;a href=&quot;#36氪&quot; class=&quot;headerlink&quot; title=&quot;36氪&quot;&gt;&lt;/a&gt;36氪&lt;/h4&gt;&lt;p&gt;微信号：wow36kr&lt;/p&gt;
&lt;p&gt;功能介绍：36氪(36kr.com)是中国最具影响力的互联网创投媒体,提供最新锐最具深度的商业报道.我们强调趋势与价值,我们的slogan是:让一部分人先看到未来.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="公众号" scheme="http://chaosky.tech/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="微信" scheme="http://chaosky.tech/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>第三方登录和分享常见问题集锦</title>
    <link href="http://chaosky.tech/2016/09/09/SNS-Platform/"/>
    <id>http://chaosky.tech/2016/09/09/SNS-Platform/</id>
    <published>2016-09-09T09:17:36.000Z</published>
    <updated>2020-03-16T07:31:28.328Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="新浪微博"><a href="#新浪微博" class="headerlink" title="新浪微博"></a>新浪微博</h2><h3 id="iOS-sso-package-or-sign-error"><a href="#iOS-sso-package-or-sign-error" class="headerlink" title="iOS sso package or sign error"></a>iOS sso package or sign error</h3><p>出现这个问题是因为在新浪微博开放平台上申请的应用的<code>Bundle ID</code>和你项目的<code>Bundle ID</code>不一致或者未设置。  </p><p>解决方法：更改新浪微博开发平台上应用的<code>Bundle ID</code></p><h3 id="error-redirect-uri-mismatch"><a href="#error-redirect-uri-mismatch" class="headerlink" title="error:redirect_uri_mismatch"></a>error:redirect_uri_mismatch</h3><p>在程序中设置的<code>Redirect URL</code>和新浪微博开放平台申请的应用的<code>授权回调页</code>URL不一致。</p><p>解决方法：在新浪微博开放平台 ——&gt; 应用信息 ——&gt; 高级信息 ——&gt; OAuth2.0 授权设置 ——&gt; 授权回调页，设置和程序的<code>Redirect URL</code>一致。</p><h3 id="新浪微博登录授权失败，responseCode等于5051"><a href="#新浪微博登录授权失败，responseCode等于5051" class="headerlink" title="新浪微博登录授权失败，responseCode等于5051"></a>新浪微博登录授权失败，responseCode等于5051</h3><p>在项目中集成友盟第三方登录，新浪微博登录，登录授权失败，返回状态码为5051（获取账户失败）。</p><p>原因：App在测试阶段(未上线)，授权的微博账号和开通开放平台的微博账号不是同一账号。</p><p>解决办法：在新浪微博开放平台中，选择我的应用——对应应用——应用信息——测试信息，选择编辑，添加测试账号。</p><h2 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h2><h3 id="scope参数错误或没有scope权限"><a href="#scope参数错误或没有scope权限" class="headerlink" title="scope参数错误或没有scope权限"></a>scope参数错误或没有scope权限</h3><ol><li>没有相关的权限</li><li>账号没有认证，没有相关的权限</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosky.tech/categories/iOS/"/>
    
    
      <category term="SNS" scheme="http://chaosky.tech/tags/SNS/"/>
    
      <category term="第三方分享" scheme="http://chaosky.tech/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%88%86%E4%BA%AB/"/>
    
      <category term="第三方登录" scheme="http://chaosky.tech/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Unix 编程艺术</title>
    <link href="http://chaosky.tech/2016/09/05/Unix-Art/"/>
    <id>http://chaosky.tech/2016/09/05/Unix-Art/</id>
    <published>2016-09-05T07:55:51.000Z</published>
    <updated>2020-03-16T07:31:28.327Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《Unix 编程艺术》：这本书在模块化、文本化、配置、接口、复杂度、优化、可移植性等方面，都提供了Unix/Linux世界所积累的宝贵经验。好的程序可以经受时间、平台与用户的考验，好的编程思想可以经受实践的检验。</p><blockquote><p>读书笔记摘录自 《Unix 编程艺术》</p></blockquote><h2 id="Unix-设计原则"><a href="#Unix-设计原则" class="headerlink" title="Unix 设计原则"></a>Unix 设计原则</h2><p>所有的 Unix 哲学浓缩为一条铁律，『KISS』原则：Keep It Simple, Stupid!</p><a id="more"></a><h3 id="Unix-管道的发明人、Unix-传统的奠基人之一-Doug-Mcllroy"><a href="#Unix-管道的发明人、Unix-传统的奠基人之一-Doug-Mcllroy" class="headerlink" title="Unix 管道的发明人、Unix 传统的奠基人之一 Doug Mcllroy"></a>Unix 管道的发明人、Unix 传统的奠基人之一 Doug Mcllroy</h3><ol><li>让每个程序就做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂。</li><li>假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的。输出中不要有无关的信息干扰。避免使用严格的分栏格式和二进制格式输入。不要坚持使用交互式输入。</li><li>尽可能早地将设计和编译的软件投入试用，哪怕是操作系统也不例外，理想情况下，应该是在几星期内。对拙劣的代码别犹豫，扔掉重写。</li><li>优先使用工具而不是拙劣的帮助来减轻编程任务的负担。工欲善其事必先利其器。</li></ol><p>一个程序只做一件事，并做好。程序要能协作。程序要能处理文本流，因为这是最通用的接口。</p><h3 id="最伟大的C语言大师之一-Rob-Pike"><a href="#最伟大的C语言大师之一-Rob-Pike" class="headerlink" title="最伟大的C语言大师之一 Rob Pike"></a>最伟大的C语言大师之一 Rob Pike</h3><ol><li><p>你无法断定程序会在什么地方耗费运行时间。瓶颈经常出现在想不到的地方，所以别急于胡乱找个地方改代码，除非你已经证实那儿就是瓶颈所在。</p></li><li><p>估量。在你没对代码进行估量，特别是没找到最耗时的那部分之前，别去优化速度。</p></li><li><p>花哨的算法在 n 很小时通常很慢，而 n 通常很小。花哨算法的常数复杂度很大。除非你确定 n 总是很大，否则不要用花哨算法（即使 n 很大，也优先考虑原则2）。</p></li><li><p>花哨的算法比简单算法更容易出 bug，更难实现。尽量使用简单的算法配合简单的数据结构。</p><blockquote><p>拿不准就穷举。</p></blockquote></li><li><p>数据压倒一切。如果已经选择了正确的数据结构并且把一切都组织得井井有条，正确的算法也就不言自明。编程的核心是数据结构，而不是算法。</p><blockquote><p>给我看流程图而不让我看数据表，我仍会迷茫不解；如果给我看数据表，通常就不需要流程图了；数据表是够说明问题了。</p></blockquote></li></ol><h3 id="Unix-哲学"><a href="#Unix-哲学" class="headerlink" title="Unix 哲学"></a>Unix 哲学</h3><h4 id="模块原则：使用简洁的接口拼合简单的部件"><a href="#模块原则：使用简洁的接口拼合简单的部件" class="headerlink" title="模块原则：使用简洁的接口拼合简单的部件"></a>模块原则：使用简洁的接口拼合简单的部件</h4><p>计算机编程的本质就是控制复杂度。</p><p>要编制复杂软件而又不至于一败涂地的唯一方法就是降低其整体复杂度——用清晰的接口把若干简单的模块组合成一个复杂软件。如此一来，多数问题只会局限于某个局部，那么就还有希望对局部进行改进而不至牵动全身。</p><h4 id="清晰原则：清晰胜于机巧"><a href="#清晰原则：清晰胜于机巧" class="headerlink" title="清晰原则：清晰胜于机巧"></a>清晰原则：清晰胜于机巧</h4><p>在写程序时，要想到你不是写给执行代码的计算机看的，而是给人——将来阅读维护源码的人，包括你自己——看的。</p><p>在选择算法和实现时就应该考虑到将来的可扩展性。而为了取得程序一丁点的性能提升就大幅度增加技术的复杂度和晦涩性，这个买卖做不得——这不仅仅是因为复杂的代码容易滋生 bug，也因为它会使日后的阅读和维护工作更加艰难。</p><p>相反，优雅而清晰的代码不仅不容易崩溃——而且更易于让后来的修改者立刻理解。</p><p>永远不要去吃力地解读语段晦涩的代码三次。</p><h4 id="组合原则：设计时考虑拼接组合"><a href="#组合原则：设计时考虑拼接组合" class="headerlink" title="组合原则：设计时考虑拼接组合"></a>组合原则：设计时考虑拼接组合</h4><p>如果程序彼此之间不能有效通信，那么软件就难免会陷入复杂度的泥淖。</p><p>在输入输出方面，Unix 传统极力提倡采用简单、文本化、面向流、设备无关的格式。文本刘界面的简洁性加强了工具的封装性。</p><p>要想让程序具有组合性，就要使程序彼此独立。在文本流这一端的程序应该尽可能不要考虑文本流另一端的程序。将一端的程序替换为另一个截然不同的程序，而完全不惊扰另一端应该很容易做到。</p><p>当程序无法自然地使用序列化、协议形式的接口时，正确的 Unix 设计至少是，把尽可能多的编程元素组织为一套定义良好的 API。这样，至少你可以通过链接调用应用程序，或者可以根据不同任务的需求粘合使用不同的接口。</p><h4 id="分离原则：策略同机制分离，接口同引擎分离"><a href="#分离原则：策略同机制分离，接口同引擎分离" class="headerlink" title="分离原则：策略同机制分离，接口同引擎分离"></a>分离原则：策略同机制分离，接口同引擎分离</h4><p>实行机制，而不是策略。因为策略和机制是按照不同的时间尺度变化的，策略的变化要远远快于机制。GUI 工具包的观感时尚来去匆匆，而光栅操作和组合却是永恒的。</p><h4 id="简洁原则：设计要简洁，复杂度能低则低"><a href="#简洁原则：设计要简洁，复杂度能低则低" class="headerlink" title="简洁原则：设计要简洁，复杂度能低则低"></a>简洁原则：设计要简洁，复杂度能低则低</h4><p>简洁而漂亮。总是设法将程序系统分解为几个能够协作的小部分，并本能地抵制任何用过多噱头来粉饰程序的企图。</p><h4 id="吝啬原则：除非确无他法，不要编写庞大的程序"><a href="#吝啬原则：除非确无他法，不要编写庞大的程序" class="headerlink" title="吝啬原则：除非确无他法，不要编写庞大的程序"></a>吝啬原则：除非确无他法，不要编写庞大的程序</h4><p>『大』有两重含义：体积大，复杂程度高。程序大了，维护起来就困难。</p><h4 id="透明性原则：设计要可见，以便审查和调试"><a href="#透明性原则：设计要可见，以便审查和调试" class="headerlink" title="透明性原则：设计要可见，以便审查和调试"></a>透明性原则：设计要可见，以便审查和调试</h4><p>因为调试通常会占用四分之三甚至更多的开发时间，所有一开始就多做点工作以减少日后调试的工作量会很划算。一个特别有效的减少调试工作量的方法就是设计时充分考虑透明性和显见性。</p><p>软件系统的透明性是指你一眼就能看出软件是在做什么以及怎么做的。显见性指程序带有监视和显示内部状态的功能，这样程序不仅能够运行良好，而且还可以看得出它以何种方式运行。</p><p>程序如果要展示其正确性，应该使用足够简单的输入输出格式，这样才能保证很容易地检验有效输入和正确输出之间的关系是否正确。</p><p>出于充分考虑透明性和显见性的目的，还应该提倡接口简洁，以方便其他程序对其进行操作——尤其是测试监视工具和调试脚本。</p><h4 id="健壮原则：健壮源于透明与简洁"><a href="#健壮原则：健壮源于透明与简洁" class="headerlink" title="健壮原则：健壮源于透明与简洁"></a>健壮原则：健壮源于透明与简洁</h4><p>软件的健壮性指软件不仅能在正常情况下运行良好，而且在超出设计者设想的意外条件下也能够运行良好。</p><p>让程序健壮的方法，就是让程序的内部逻辑更易于理解。要做到这一点主要两种方法：透明化和简洁化。</p><p>在有异常输入的情况下，保证软件健壮性的一个相当重要的策略就是避免在代码中出现特例。bug 通常隐藏在处理特例的代码以及处理不同特殊情况的交互操作部分的代码中。</p><p>模块性（代码简朴，接口简洁）是组织程序以达到更简洁目的的一个方法。</p><h4 id="表示原则：把知识叠入数据以求逻辑质朴而健壮"><a href="#表示原则：把知识叠入数据以求逻辑质朴而健壮" class="headerlink" title="表示原则：把知识叠入数据以求逻辑质朴而健壮"></a>表示原则：把知识叠入数据以求逻辑质朴而健壮</h4><p>即使最简单的程序逻辑让人类来验证也很困难，但是就算是很复杂的数据，对人类来说，还是相对容易地就能够推导和建模的。</p><p>数据要比编程逻辑更容易驾驭。所以接下来，如果要在复杂数据和复杂代码中选择一个，宁愿选择前者。更进一步：在设计中，你应该主动将代码的复杂度转移到数据之中去。</p><p>特别是 C 语言对指针使用控制的功能，促进了在内核以上各个编码层面上对动态修改引用结构。在结构中用非常简单的指针操作就能够完成的任务，在其他语言中，往往不得不用更复杂的过程才能完成。</p><h4 id="通俗原则：接口设计避免标新立异"><a href="#通俗原则：接口设计避免标新立异" class="headerlink" title="通俗原则：接口设计避免标新立异"></a>通俗原则：接口设计避免标新立异</h4><p>也就是众所周知的『最少惊奇原则』。</p><p>最易用的程序就是用户需要学习新东西最少的程序——或者，换句话说，最易用的程序就是最切合用户已有知识的程序。</p><p>接口设计应该避免毫无来由的标新立异和自作聪明；关注目标受众，对于不同的人群，最少惊奇的意义也不同；关注传统惯例，Unix 世界形成了一套系统的惯例，这些惯例的存在有个极好的理由：缓和学习曲线。</p><h4 id="缄默原则：如果一个程序没什么好说的，就保持沉默"><a href="#缄默原则：如果一个程序没什么好说的，就保持沉默" class="headerlink" title="缄默原则：如果一个程序没什么好说的，就保持沉默"></a>缄默原则：如果一个程序没什么好说的，就保持沉默</h4><p>Unix 中最古老最持久的设计原则之一就是：若程序没有什么特别之处可讲，就保持沉默。行为良好的程序应该默默工作，决不唠唠叨叨，碍手碍脚。沉默是金。</p><p>设计良好的程序将用户的注意力视为有限的宝贵资源，只有在必要时才要求使用。</p><h4 id="补救原则：出现异常时，马上退出并给出足量错误信息"><a href="#补救原则：出现异常时，马上退出并给出足量错误信息" class="headerlink" title="补救原则：出现异常时，马上退出并给出足量错误信息"></a>补救原则：出现异常时，马上退出并给出足量错误信息</h4><p>软件在发生错误的时候也应该与在正常操作的情况下一样，有透明的逻辑。最理想的情况当然是软件能够适应和应付非正常操作；而如果补救措施明明没有成功，却悄无声息地埋下崩溃的隐患，直到很久以后才显现出来，这就是最坏的一种情况。</p><p>因此，软件要尽可能从容地应付各种错误输入和自身的运行错误。但是，如果做不到这一点，就让程序尽可能以一种容易诊断错误的方式终止。</p><h4 id="经济原则：宁花机器一分，不花程序员一秒"><a href="#经济原则：宁花机器一分，不花程序员一秒" class="headerlink" title="经济原则：宁花机器一分，不花程序员一秒"></a>经济原则：宁花机器一分，不花程序员一秒</h4><h4 id="生成原则：避免手工-hack，尽量编写程序去生成程序"><a href="#生成原则：避免手工-hack，尽量编写程序去生成程序" class="headerlink" title="生成原则：避免手工 hack，尽量编写程序去生成程序"></a>生成原则：避免手工 hack，尽量编写程序去生成程序</h4><p>程序中的任何手工 hacking 都是滋生错误和延误的温床。程序规格越简单抽象，设计者就越容易做对。有程序生成代码几乎（在各个层次）总是比手写代码廉价并且更值得信赖。</p><h4 id="优化原则：雕琢前先得有原型，跑之前先学会走"><a href="#优化原则：雕琢前先得有原型，跑之前先学会走" class="headerlink" title="优化原则：雕琢前先得有原型，跑之前先学会走"></a>优化原则：雕琢前先得有原型，跑之前先学会走</h4><p>原型设计最基本的原则：『90%的功能现在能实现，比100%的功能永远实现不了强』。做好原型设计可以帮助你避免为蝇头小利而投入过多的时间。</p><p>过早的优化是万恶之源。</p><p>还不知道瓶颈所在就匆忙进行优化，这可能是唯一一个比乱加功能更损害设计的错误。从畸形的代码到杂乱无章的数据布局，牺牲透明性和简洁性而片面追求速度、内存或者磁盘使用的后果随处可见。滋生无数 bug，耗费以百万计的人时——这点芝麻大的好处，远不能抵消后续排错所付出的代价。</p><p>先制作原型，在精雕细琢。优化之前先确保能用。</p><p>先求运行，再求正确，最后求快。</p><p>先给你的设计做个未优化的、运行缓慢、很耗内存但是正确的实现，然后进行系统地调整，寻找那些可以通过牺牲最小的局部简洁性而获得较大性能提升的地方。</p><p>制作原型对于系统设计和优化同样重要——比起阅读一个冗长的规格说明，判断一个原型究竟是不是符合设想要容易得多。借助原型化找出哪些功能不必实现，有助于对性能进行优化；那些不用写的代码显然无需优化。</p><h4 id="多样原则：绝不相信所谓『不二法门』的断言"><a href="#多样原则：绝不相信所谓『不二法门』的断言" class="headerlink" title="多样原则：绝不相信所谓『不二法门』的断言"></a>多样原则：绝不相信所谓『不二法门』的断言</h4><p>即使最出色的软件也常常会受限于设计者的想象力。没有人能聪明到把所有东西都最优化，也不可能预想到软件所有可能的用途。设计一个僵化、封闭、不愿与外界沟通的软件，简直就是一种病态的傲慢。</p><p>Unix 奉行的是广泛采用多种语言、开放的可扩展系统和用户定制机制。</p><h4 id="扩展原则：设计着眼未来，未来总比预想快"><a href="#扩展原则：设计着眼未来，未来总比预想快" class="headerlink" title="扩展原则：设计着眼未来，未来总比预想快"></a>扩展原则：设计着眼未来，未来总比预想快</h4><p>为数据格式和代码留下扩展的空间，否则，就会发现自己常常被原先的不明智选择捆住了手脚，因为你无法既要改变他们又要维持对原来的兼容性。</p><p>设计协议或者文件格式时，应使其具有充分的自描述性以便可以扩展。</p><p>设计代码时，要有很好的组织，让将来的开发者增加新功能时无需拆毁或者重建整个架构。</p><h3 id="运用-Unix-哲学"><a href="#运用-Unix-哲学" class="headerlink" title="运用 Unix 哲学"></a>运用 Unix 哲学</h3><p>要良好的运用 Unix 哲学，你就应该不断追求卓越。你必须相信，软件设计时一门技艺，值得你付出所有的智慧、创造力和激情。否则，你的视线就不会超越哪些简单、老套的设计和实现：你就会在应该思考的时候急急忙忙跑去编程。你就会在该无情删繁就简的时候反而把问题复杂化——然后你还会反过来奇怪你的代码怎么会那么臃肿、那么难以调试，</p><p>要良好地运用 Unix 哲学，你应该珍惜你的时间绝不浪费。一旦某人已经解决了某个问题，就直接拿来利用，不要让骄傲或偏见拽住你又去重做一遍。永远不要蛮干：要多用巧劲，省下力气到需要的时候在用，好钢用在刀刃上。善用工具，尽可能将一切都自动化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Unix 编程艺术》：这本书在模块化、文本化、配置、接口、复杂度、优化、可移植性等方面，都提供了Unix/Linux世界所积累的宝贵经验。好的程序可以经受时间、平台与用户的考验，好的编程思想可以经受实践的检验。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;读书笔记摘录自 《Unix 编程艺术》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Unix-设计原则&quot;&gt;&lt;a href=&quot;#Unix-设计原则&quot; class=&quot;headerlink&quot; title=&quot;Unix 设计原则&quot;&gt;&lt;/a&gt;Unix 设计原则&lt;/h2&gt;&lt;p&gt;所有的 Unix 哲学浓缩为一条铁律，『KISS』原则：Keep It Simple, Stupid!&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件设计" scheme="http://chaosky.tech/categories/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Unix 编程艺术" scheme="http://chaosky.tech/tags/Unix-%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"/>
    
  </entry>
  
</feed>
